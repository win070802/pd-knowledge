const { GoogleGenerativeAI } = require('@google/generative-ai');
const { db } = require('../../../database');
const ContentClassifier = require('../../utils/content/contentClassifier');

class QuestionAnalysisService {
  constructor() {
    this.genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
    this.model = this.genAI.getGenerativeModel({ model: 'gemini-2.5-flash' });
    this.contentClassifier = new ContentClassifier();
  }

  /**
   * Ph√¢n t√≠ch c√¢u h·ªèi ƒë·ªÉ x√°c ƒë·ªãnh intent v√† ngu·ªìn d·ªØ li·ªáu
   * @param {string} question - C√¢u h·ªèi c·ªßa ng∆∞·ªùi d√πng
   * @param {string} sessionId - ID phi√™n h·ªôi tho·∫°i
   * @returns {Object} K·∫øt qu·∫£ ph√¢n t√≠ch
   */
  async analyzeQuestion(question, sessionId) {
    try {
      console.log(`üîç Analyzing question: "${question}"`);
      
      // L·∫•y context t·ª´ session
      const context = await this.getSessionContext(sessionId);
      
      // Chu·∫©n b·ªã d·ªØ li·ªáu cho ph√¢n t√≠ch
      const questionLower = question.toLowerCase();
      
      // Ph√¢n t√≠ch intent
      const intent = this.detectIntent(questionLower);
      
      // Ph√¢n t√≠ch ngu·ªìn d·ªØ li·ªáu
      const source = this.detectDataSource(questionLower, intent);
      
      // Ph√¢n t√≠ch ch·ªß ƒë·ªÅ
      const topic = this.detectTopic(questionLower);
      
      // Ph√¢n t√≠ch c√¥ng ty
      const company = await this.detectCompany(questionLower);
      
      // Ph√¢n t√≠ch ph√≤ng ban
      const department = this.detectDepartment(questionLower);
      
      // T√≠nh to√°n ƒë·ªô tin c·∫≠y
      const confidence = this.calculateConfidence(intent, source, topic, company, department);
      
      console.log(`‚úÖ Analysis result:`, { intent, source, topic, company, department, confidence });
      
      return {
        intent,
        source,
        topic,
        company,
        department,
        confidence,
        sessionContext: context,
        error: null
      };
    } catch (error) {
      console.error('Error analyzing question:', error);
      return {
        intent: 'unknown',
        source: 'unknown',
        topic: null,
        company: null,
        department: null,
        confidence: 0,
        sessionContext: {},
        error: error.message
      };
    }
  }
  
  /**
   * Ph√¢n t√≠ch intent c·ªßa c√¢u h·ªèi
   * @param {string} question - C√¢u h·ªèi c·∫ßn ph√¢n t√≠ch
   * @returns {Object} K·∫øt qu·∫£ ph√¢n t√≠ch intent
   */
  async analyzeQuestionIntent(question) {
    try {
      // Ki·ªÉm tra tr∆∞·ªõc b·∫±ng c√°c pattern ƒë·∫∑c bi·ªát
      const questionLower = question.toLowerCase();
      
      // Pattern cho danh s√°ch t√†i li·ªáu
      if (/(danh s√°ch|list|li·ªát k√™|show|hi·ªÉn th·ªã|xem).*(t√†i li·ªáu|document|file|vƒÉn b·∫£n|quy ƒë·ªãnh|quy tr√¨nh)/i.test(questionLower)) {
        const company = this.extractCompanyFromQuestion(question);
        return {
          intent: 'list_documents',
          target: 'documents',
          company: company,
          category: null,
          confidence: 90
        };
      }
      
      // Pattern cho danh s√°ch c√¥ng ty
      if (/(danh s√°ch|list|li·ªát k√™|show|hi·ªÉn th·ªã|xem).*(c√¥ng ty|company|t·∫≠p ƒëo√†n|group)/i.test(questionLower)) {
        return {
          intent: 'list_companies',
          target: 'knowledge',
          company: null,
          category: null,
          confidence: 90
        };
      }
      
      const analysisPrompt = `
Ph√¢n t√≠ch c√¢u h·ªèi sau ƒë√¢y v√† tr·∫£ v·ªÅ JSON format v·ªõi c√°c th√¥ng tin:

C√¢u h·ªèi: "${question}"

H√£y ph√¢n t√≠ch:
1. INTENT: Ng∆∞·ªùi d√πng mu·ªën g√¨? (list_companies, list_documents, find_knowledge, hybrid_search, general_question)
2. TARGET: T√¨m g√¨? (documents, knowledge, both)  
3. COMPANY: C√¥ng ty n√†o? (PDH, PDI, PDE, PDHOS, RHS, ho·∫∑c null)
4. CATEGORY: Lo·∫°i th√¥ng tin? (IT, HR, Finance, Legal, Operations, ho·∫∑c null)
5. CONFIDENCE: ƒê·ªô tin c·∫≠y (0-100)

C√°c INTENT types:
- list_companies: Mu·ªën xem danh s√°ch c√°c c√¥ng ty trong t·∫≠p ƒëo√†n
- list_documents: Mu·ªën xem danh s√°ch, li·ªát k√™ t√†i li·ªáu/file
- find_knowledge: H·ªèi v·ªÅ th√¥ng tin c·ª• th·ªÉ ƒë√£ h·ªçc (nh√¢n s·ª±, quy tr√¨nh...)
- hybrid_search: C·∫ßn t√¨m trong c·∫£ documents + knowledge 
- general_question: C√¢u h·ªèi chung chung

C√°c t·ª´ kh√≥a ch·ªâ hybrid_search:
- "t√≥m t·∫Øt", "gi·∫£i th√≠ch", "m√¥ t·∫£", "chi ti·∫øt v·ªÅ"
- "quy tr√¨nh", "quy ƒë·ªãnh", "ch√≠nh s√°ch", "h∆∞·ªõng d·∫´n"
- "n·ªôi dung", "th√¥ng tin trong", "theo t√†i li·ªáu"
- "h·ªá th·ªëng", "c∆° ch·∫ø", "c√°ch th·ª©c"

C√°c t·ª´ kh√≥a ch·ªâ list_documents:
- "danh s√°ch t√†i li·ªáu", "li·ªát k√™ t√†i li·ªáu", "li·ªát k√™ file"
- "t√†i li·ªáu thu·ªôc", "t√†i li·ªáu c·ªßa", "t√†i li·ªáu li√™n quan ƒë·∫øn"
- "xem t√†i li·ªáu c·ªßa", "hi·ªÉn th·ªã t√†i li·ªáu"

Ch·ªâ tr·∫£ v·ªÅ JSON, kh√¥ng gi·∫£i th√≠ch:`;

      const result = await this.model.generateContent(analysisPrompt);
      const response = result.response;
      const text = response.text();
      
      // Extract JSON from response
      console.log(`üß† Raw AI response:`, text);
      
      // Try to find JSON in the response
      let analysis = null;
      
      // First try: Find complete JSON object
      const jsonMatch = text.match(/\{[^{}]*\}/);
      if (jsonMatch) {
        try {
          analysis = JSON.parse(jsonMatch[0]);
          console.log(`üß† AI Intent Analysis:`, analysis);
          return analysis;
        } catch (parseError) {
          console.error('JSON parse error:', parseError);
        }
      }
      
      // Second try: Extract key-value pairs manually
      const intentMatch = text.match(/"intent"\s*:\s*"([^"]+)"/);
      const targetMatch = text.match(/"target"\s*:\s*"([^"]+)"/);
      const companyMatch = text.match(/"company"\s*:\s*"?([^",}]+)"?/);
      const categoryMatch = text.match(/"category"\s*:\s*"?([^",}]+)"?/);
      const confidenceMatch = text.match(/"confidence"\s*:\s*(\d+)/);
      
      if (intentMatch) {
        analysis = {
          intent: intentMatch[1],
          target: targetMatch ? targetMatch[1] : 'both',
          company: companyMatch ? companyMatch[1] : null,
          category: categoryMatch ? categoryMatch[1] : null,
          confidence: confidenceMatch ? parseInt(confidenceMatch[1]) : 70
        };
        console.log(`üß† Manually parsed intent:`, analysis);
        return analysis;
      }
      
      // Fallback to basic analysis
      return {
        intent: 'general_question',
        target: 'both', 
        company: this.extractCompanyFromQuestion(question),
        category: null,
        confidence: 50
      };
      
    } catch (error) {
      console.error('Error in intent analysis:', error);
      // Fallback to basic logic
      return {
        intent: 'general_question',
        target: 'both',
        company: this.extractCompanyFromQuestion(question),
        category: null,
        confidence: 30
      };
    }
  }
  
  /**
   * Ph√°t hi·ªán intent t·ª´ c√¢u h·ªèi
   * @param {string} question - C√¢u h·ªèi c·ªßa ng∆∞·ªùi d√πng
   * @returns {string} Intent c·ªßa c√¢u h·ªèi
   */
  detectIntent(question) {
    // Ki·ªÉm tra intent danh s√°ch t√†i li·ªáu
    if (/(danh s√°ch|li·ªát k√™|list|show|hi·ªÉn th·ªã|xem).*(t√†i li·ªáu|document|file|vƒÉn b·∫£n|quy ƒë·ªãnh|quy tr√¨nh)/i.test(question)) {
      return 'list_documents';
    }
    
    // Ki·ªÉm tra intent t√¨m ki·∫øm t√†i li·ªáu c·ª• th·ªÉ
    if (/(t√¨m|search|look for|find).*(t√†i li·ªáu|document|file|vƒÉn b·∫£n|quy ƒë·ªãnh|quy tr√¨nh)/i.test(question)) {
      return 'search_document';
    }
    
    // Ki·ªÉm tra intent t√≥m t·∫Øt t√†i li·ªáu
    if (/(t√≥m t·∫Øt|summary|summarize|t√≥m l∆∞·ª£c).*(t√†i li·ªáu|document|file|vƒÉn b·∫£n|quy ƒë·ªãnh|quy tr√¨nh)/i.test(question)) {
      return 'summarize_document';
    }
    
    // Ki·ªÉm tra intent th√¥ng tin c√¥ng ty
    if (/(th√¥ng tin|information|info|gi·ªõi thi·ªáu|v·ªÅ).*(c√¥ng ty|company)/i.test(question)) {
      return 'company_info';
    }
    
    // Ki·ªÉm tra intent h·ªèi v·ªÅ ng∆∞·ªùi l√£nh ƒë·∫°o
    if (/(ai|who|ng∆∞·ªùi n√†o).*(gi√°m ƒë·ªëc|ceo|ch·ªß t·ªãch|chairman|l√£nh ƒë·∫°o|leader)/i.test(question)) {
      return 'leadership_info';
    }
    
    // M·∫∑c ƒë·ªãnh l√† c√¢u h·ªèi chung
    return 'general_question';
  }

  /**
   * Ph√°t hi·ªán ngu·ªìn d·ªØ li·ªáu t·ª´ c√¢u h·ªèi v√† intent
   * @param {string} question - C√¢u h·ªèi c·ªßa ng∆∞·ªùi d√πng
   * @param {string} intent - Intent c·ªßa c√¢u h·ªèi
   * @returns {string} Ngu·ªìn d·ªØ li·ªáu
   */
  detectDataSource(question, intent) {
    // N·∫øu c√¢u h·ªèi li√™n quan ƒë·∫øn t√†i li·ªáu
    if (/(t√†i li·ªáu|document|file|vƒÉn b·∫£n|quy ƒë·ªãnh|quy tr√¨nh)/i.test(question) || 
        intent === 'list_documents' || 
        intent === 'search_document' || 
        intent === 'summarize_document') {
      return 'documents';
    }
    
    // N·∫øu c√¢u h·ªèi li√™n quan ƒë·∫øn th√¥ng tin c√¥ng ty
    if (/(c√¥ng ty|company|t·ªï ch·ª©c|organization)/i.test(question) || 
        intent === 'company_info' || 
        intent === 'leadership_info') {
      return 'knowledge_base';
    }
    
    // N·∫øu c√≥ c·∫£ hai, s·ª≠ d·ª•ng c·∫£ hai ngu·ªìn
    if (/(t√†i li·ªáu|document).*(c√¥ng ty|company)/i.test(question) || 
        /(c√¥ng ty|company).*(t√†i li·ªáu|document)/i.test(question)) {
      return 'hybrid';
    }
    
    // M·∫∑c ƒë·ªãnh s·ª≠ d·ª•ng constraints
    return 'constraints';
  }

  /**
   * Ph√°t hi·ªán ph√≤ng ban t·ª´ c√¢u h·ªèi
   * @param {string} question - C√¢u h·ªèi c·∫ßn ph√¢n t√≠ch
   * @returns {string|null} T√™n ph√≤ng ban ho·∫∑c null
   */
  detectDepartment(question) {
    const questionLower = question.toLowerCase();
    
    // C√°c t·ª´ kh√≥a ph√≤ng ban
    const departmentKeywords = {
      'it': ['it', 'c√¥ng ngh·ªá th√¥ng tin', 'cntt', 'ph√≤ng it', 'ban it', 'technology'],
      'hr': ['hr', 'nh√¢n s·ª±', 'human resource', 'ph√≤ng nh√¢n s·ª±', 'ban nh√¢n s·ª±', 'tuy·ªÉn d·ª•ng'],
      'finance': ['t√†i ch√≠nh', 'finance', 'k·∫ø to√°n', 'accounting', 'ph√≤ng t√†i ch√≠nh', 'ban t√†i ch√≠nh'],
      'legal': ['ph√°p ch·∫ø', 'legal', 'ph√°p l√Ω', 'ph√≤ng ph√°p ch·∫ø', 'ban ph√°p ch·∫ø'],
      'operations': ['v·∫≠n h√†nh', 'operations', 'ph√≤ng v·∫≠n h√†nh', 'ban v·∫≠n h√†nh'],
      'sales': ['kinh doanh', 'sales', 'b√°n h√†ng', 'ph√≤ng kinh doanh', 'ban kinh doanh'],
      'marketing': ['marketing', 'ti·∫øp th·ªã', 'ph√≤ng marketing', 'ban marketing']
    };
    
    // Ki·ªÉm tra t·ª´ng ph√≤ng ban
    for (const [dept, keywords] of Object.entries(departmentKeywords)) {
      for (const keyword of keywords) {
        if (questionLower.includes(keyword)) {
          return dept;
        }
      }
    }
    
    return null;
  }
  
  /**
   * Ph√°t hi·ªán ch·ªß ƒë·ªÅ t·ª´ c√¢u h·ªèi
   * @param {string} question - C√¢u h·ªèi c·ªßa ng∆∞·ªùi d√πng
   * @returns {string|null} Ch·ªß ƒë·ªÅ ho·∫∑c null n·∫øu kh√¥ng t√¨m th·∫•y
   */
  detectTopic(question) {
    // Danh s√°ch c√°c ch·ªß ƒë·ªÅ v√† pattern t∆∞∆°ng ·ª©ng
    const topics = [
      { pattern: /(quy tr√¨nh|process|procedure|workflow)/i, topic: 'process' },
      { pattern: /(quy ƒë·ªãnh|regulation|rule|policy)/i, topic: 'regulation' },
      { pattern: /(b√°o c√°o|report|reporting)/i, topic: 'report' },
      { pattern: /(t√†i ch√≠nh|financial|finance|k·∫ø to√°n|accounting)/i, topic: 'financial' },
      { pattern: /(nh√¢n s·ª±|hr|human resource|personnel)/i, topic: 'hr' },
      { pattern: /(marketing|ti·∫øp th·ªã|qu·∫£ng c√°o|advertising)/i, topic: 'marketing' },
      { pattern: /(s·∫£n xu·∫•t|production|manufacturing)/i, topic: 'production' },
      { pattern: /(c√¥ng ngh·ªá|technology|it|ph·∫ßn m·ªÅm|software)/i, topic: 'technology' },
      { pattern: /(ph√°p l√Ω|legal|lu·∫≠t|law)/i, topic: 'legal' }
    ];
    
    // Ki·ªÉm tra t·ª´ng pattern
    for (const { pattern, topic } of topics) {
      if (pattern.test(question)) {
        return topic;
      }
    }
    
    return null;
  }

  /**
   * T√≠nh to√°n ƒë·ªô tin c·∫≠y c·ªßa ph√¢n t√≠ch
   * @param {string} intent - Intent c·ªßa c√¢u h·ªèi
   * @param {string} source - Ngu·ªìn d·ªØ li·ªáu
   * @param {string|null} topic - Ch·ªß ƒë·ªÅ
   * @param {string|null} company - C√¥ng ty
   * @param {string|null} department - Ph√≤ng ban
   * @returns {number} ƒê·ªô tin c·∫≠y (0-100)
   */
  calculateConfidence(intent, source, topic, company, department) {
    let confidence = 50; // ƒêi·ªÉm c∆° b·∫£n
    
    // TƒÉng ƒëi·ªÉm n·∫øu c√≥ intent r√µ r√†ng
    if (intent && intent !== 'general_question') {
      confidence += 10;
    }
    
    // TƒÉng ƒëi·ªÉm n·∫øu c√≥ ngu·ªìn d·ªØ li·ªáu c·ª• th·ªÉ
    if (source && source !== 'constraints') {
      confidence += 10;
    }
    
    // TƒÉng ƒëi·ªÉm n·∫øu c√≥ ch·ªß ƒë·ªÅ
    if (topic) {
      confidence += 10;
    }
    
    // TƒÉng ƒëi·ªÉm n·∫øu c√≥ c√¥ng ty
    if (company) {
      confidence += 10;
    }
    
    // TƒÉng ƒëi·ªÉm n·∫øu c√≥ ph√≤ng ban
    if (department) {
      confidence += 10;
    }
    
    // ƒê·∫£m b·∫£o confidence kh√¥ng v∆∞·ª£t qu√° 100
    return Math.min(confidence, 100);
  }

  /**
   * Tr√≠ch xu·∫•t t√™n c√¥ng ty t·ª´ c√¢u h·ªèi
   * @param {string} question - C√¢u h·ªèi c·∫ßn ph√¢n t√≠ch
   * @returns {string|null} T√™n c√¥ng ty ho·∫∑c null
   */
  extractCompanyFromQuestion(question) {
    try {
      // Danh s√°ch c√°c m√£ c√¥ng ty
      const companyPatterns = [
        { pattern: /\b(pdh|ph√°t ƒë·∫°t holdings|phat dat holdings)\b/i, code: 'PDH' },
        { pattern: /\b(pdi|ph√°t ƒë·∫°t invest|phat dat invest)\b/i, code: 'PDI' },
        { pattern: /\b(pde|ph√°t ƒë·∫°t edu|phat dat edu|ph√°t ƒë·∫°t education)\b/i, code: 'PDE' },
        { pattern: /\b(pdhos|ph√°t ƒë·∫°t hospital|phat dat hospital|ph√°t ƒë·∫°t b·ªánh vi·ªán)\b/i, code: 'PDHOS' },
        { pattern: /\b(rhs|roman hospital|b·ªánh vi·ªán roman)\b/i, code: 'RHS' }
      ];
      
      const questionLower = question.toLowerCase();
      
      // T√¨m c√¥ng ty trong c√¢u h·ªèi
      for (const company of companyPatterns) {
        if (company.pattern.test(questionLower)) {
          return company.code;
        }
      }
      
      // Ki·ªÉm tra chu·ªói ƒë∆∞·ª£c b·ªçc trong d·∫•u ngo·∫∑c - c√≥ th·ªÉ l√† m√£ c√¥ng ty
      const bracketMatch = question.match(/\(([A-Z0-9]{3,6})\)/);
      if (bracketMatch) {
        const possibleCompanyCode = bracketMatch[1];
        const validCompanyCodes = ['PDH', 'PDI', 'PDE', 'PDHOS', 'RHS'];
        if (validCompanyCodes.includes(possibleCompanyCode)) {
          return possibleCompanyCode;
        }
      }
      
      return null;
    } catch (error) {
      console.error('Error extracting company:', error);
      return null;
    }
  }

  /**
   * Ph√°t hi·ªán t√™n t√†i li·ªáu c·ª• th·ªÉ trong c√¢u h·ªèi
   * @param {string} question - C√¢u h·ªèi c·∫ßn ph√¢n t√≠ch
   * @returns {boolean} C√≥ ph√°t hi·ªán t√™n t√†i li·ªáu c·ª• th·ªÉ hay kh√¥ng
   */
  detectSpecificDocument(question) {
    // Ki·ªÉm tra c√°c ƒë·ªãnh d·∫°ng t√†i li·ªáu c·ª• th·ªÉ
    const documentPatterns = [
      /\b[A-Z0-9]{2,10}-[A-Z0-9]{2,10}(-[A-Z0-9]{2,10})*\b/, // M√£ t√†i li·ªáu: QT-NS-01
      /\b\w+\.(pdf|docx?|xlsx?|pptx?|txt)\b/i, // T√™n file v·ªõi extension
      /"([^"]+\.(pdf|doc|docx|xls|xlsx|ppt|pptx|txt))"/i, // T√™n file trong d·∫•u ngo·∫∑c k√©p
      /'([^']+\.(pdf|doc|docx|xls|xlsx|ppt|pptx|txt))'/i, // T√™n file trong d·∫•u ngo·∫∑c ƒë∆°n
      /\b(quy tr√¨nh|quy ƒë·ªãnh|ch√≠nh s√°ch|h∆∞·ªõng d·∫´n|s∆° ƒë·ªì|bi·ªÉu m·∫´u) [a-zA-Z0-9\s]{3,30}\b/i, // "quy tr√¨nh l√†m vi·ªác"
      /\b(process|policy|procedure|guideline|form|template) [a-zA-Z0-9\s]{3,30}\b/i // "leave policy"
    ];
    
    return documentPatterns.some(pattern => pattern.test(question));
  }
  
  /**
   * Ph√°t hi·ªán c√¥ng ty t·ª´ c√¢u h·ªèi
   * @param {string} question - C√¢u h·ªèi c·ªßa ng∆∞·ªùi d√πng
   * @returns {string|null} M√£ c√¥ng ty ho·∫∑c null n·∫øu kh√¥ng t√¨m th·∫•y
   */
  async detectCompany(question) {
    try {
      // L·∫•y t·∫•t c·∫£ c√¥ng ty t·ª´ database
      const { pool } = require('../../config/database');
      const client = await pool.connect();
      try {
        // L·∫•y t·∫•t c·∫£ c√¥ng ty t·ª´ database
        const result = await client.query(`
          SELECT company_code, company_name, short_name, description
          FROM companies
        `);
        
        if (result.rows.length === 0) {
          console.log('‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y c√¥ng ty n√†o trong database');
          return null;
        }
        
        // Chu·∫©n b·ªã t·ª´ kh√≥a t√¨m ki·∫øm
        const normalizedQuestion = question.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "");
        
        // T·∫°o danh s√°ch c√°c m·∫´u t√¨m ki·∫øm t·ª´ d·ªØ li·ªáu c√¥ng ty
        const companyPatterns = [];
        
        for (const company of result.rows) {
          // T·∫°o pattern t·ª´ m√£ c√¥ng ty
          const codePattern = new RegExp(`\\b${company.company_code.toLowerCase()}\\b`, 'i');
          companyPatterns.push({ pattern: codePattern, code: company.company_code });
          
          // T·∫°o pattern t·ª´ t√™n c√¥ng ty
          if (company.company_name) {
            const namePattern = new RegExp(`\\b${company.company_name.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "")}\\b`, 'i');
            companyPatterns.push({ pattern: namePattern, code: company.company_code });
          }
          
          // T·∫°o pattern t·ª´ t√™n vi·∫øt t·∫Øt
          if (company.short_name) {
            const shortNamePattern = new RegExp(`\\b${company.short_name.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "")}\\b`, 'i');
            companyPatterns.push({ pattern: shortNamePattern, code: company.company_code });
          }
        }
        
        // Ki·ªÉm tra t·ª´ng pattern
        for (const { pattern, code } of companyPatterns) {
          if (pattern.test(normalizedQuestion)) {
            console.log(`üè¢ Detected company: ${code}`);
            return code;
          }
        }
        
        // N·∫øu kh√¥ng t√¨m th·∫•y b·∫±ng pattern, th·ª≠ t√¨m ki·∫øm t·ª´ng ph·∫ßn
        for (const company of result.rows) {
          const companyCode = company.company_code.toLowerCase();
          const companyName = company.company_name ? company.company_name.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "") : '';
          const shortName = company.short_name ? company.short_name.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "") : '';
          
          if (normalizedQuestion.includes(companyCode.toLowerCase()) || 
              (companyName && normalizedQuestion.includes(companyName)) || 
              (shortName && normalizedQuestion.includes(shortName))) {
            console.log(`üè¢ Detected company from partial match: ${company.company_code}`);
            return company.company_code;
          }
        }
        
        return null;
      } finally {
        client.release();
      }
    } catch (error) {
      console.error('Error detecting company:', error);
      return null;
    }
  }

  /**
   * L·∫•y ng·ªØ c·∫£nh phi√™n h·ªôi tho·∫°i
   * @param {string} sessionId - ID phi√™n h·ªôi tho·∫°i
   * @returns {Object} Ng·ªØ c·∫£nh phi√™n
   */
  async getSessionContext(sessionId) {
    try {
      const { pool } = require('../../config/database');
      
      // Get conversation context
      const sessionQuery = await pool.query(
        'SELECT context FROM conversations WHERE session_id = $1 AND is_active = true',
        [sessionId]
      );
      
      if (sessionQuery.rows.length > 0) {
        return sessionQuery.rows[0].context || {};
      }
      
      return {};
    } catch (error) {
      console.error('Error getting session context:', error);
      return {};
    }
  }
}

module.exports = QuestionAnalysisService; 
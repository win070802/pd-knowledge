const { GoogleGenerativeAI } = require('@google/generative-ai');
const { db } = require('../../../database');
const ContentClassifier = require('../../utils/content/contentClassifier');

class QuestionAnalysisService {
  constructor() {
    this.genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
    this.model = this.genAI.getGenerativeModel({ model: 'gemini-2.5-flash' });
    this.contentClassifier = new ContentClassifier();
  }

  /**
   * Ph√¢n t√≠ch c√¢u h·ªèi ƒë·ªÉ x√°c ƒë·ªãnh intent, ch·ªß ƒë·ªÅ v√† ngu·ªìn d·ªØ li·ªáu ph√π h·ª£p
   * @param {string} question - C√¢u h·ªèi c·ªßa ng∆∞·ªùi d√πng
   * @param {string} sessionId - ID phi√™n h·ªôi tho·∫°i
   * @returns {Object} K·∫øt qu·∫£ ph√¢n t√≠ch
   */
  async analyzeQuestion(question, sessionId = null) {
    try {
      console.log(`üîç Analyzing question: "${question}"`);
      
      // Ki·ªÉm tra n·ªôi dung nh·∫°y c·∫£m
      const isSensitive = await this.contentClassifier.isSensitiveContent(question);
      if (isSensitive) {
        return {
          intent: 'sensitive_content',
          source: 'none',
          topic: 'sensitive',
          company: null,
          department: null,
          confidence: 100,
          sessionContext: {},
          error: 'C√¢u h·ªèi ch·ª©a n·ªôi dung nh·∫°y c·∫£m kh√¥ng ƒë∆∞·ª£c ph√©p'
        };
      }
      
      // Ph√¢n t√≠ch ng·ªØ c·∫£nh phi√™n h·ªôi tho·∫°i
      let sessionContext = {};
      if (sessionId) {
        sessionContext = await this.getSessionContext(sessionId);
      }
      
      // Ki·ªÉm tra n·∫øu c√¢u h·ªèi l√† y√™u c·∫ßu danh s√°ch t√†i li·ªáu theo c√¥ng ty
      const documentListPattern = /(danh s√°ch|li·ªát k√™|list|show|hi·ªÉn th·ªã|xem).*(t√†i li·ªáu|document|file|vƒÉn b·∫£n|quy ƒë·ªãnh|quy tr√¨nh).*(c·ªßa|thu·ªôc|trong|·ªü|t·∫°i|li√™n quan ƒë·∫øn|about).*?(PDH|PDI|PDE|PDHOS|RHS)/i;
      const documentListPatternCompanyFirst = /(PDH|PDI|PDE|PDHOS|RHS).*(danh s√°ch|li·ªát k√™|list|show|hi·ªÉn th·ªã|xem).*(t√†i li·ªáu|document|file|vƒÉn b·∫£n|quy ƒë·ªãnh|quy tr√¨nh)/i;
      
      if (documentListPattern.test(question) || documentListPatternCompanyFirst.test(question)) {
        const company = this.extractCompanyFromQuestion(question);
        console.log(`üìë Detected document list request for company: ${company}`);
        return {
          intent: 'list_documents',
          source: 'documents',
          topic: null,
          company: company,
          department: this.detectDepartment(question),
          confidence: 95,
          sessionContext: sessionContext,
          error: null
        };
      }
      
      // Ki·ªÉm tra n·∫øu c√¢u h·ªèi ch·ª©a t√™n t√†i li·ªáu c·ª• th·ªÉ
      const hasSpecificDocumentName = this.detectSpecificDocument(question);
      if (hasSpecificDocumentName) {
        console.log(`üìÑ Detected specific document name in question`);
        return {
          intent: 'document_specific',
          source: 'documents',
          topic: this.detectTopic(question),
          company: this.extractCompanyFromQuestion(question),
          department: this.detectDepartment(question),
          confidence: 90,
          sessionContext: sessionContext,
          error: null
        };
      }
      
      // Ki·ªÉm tra n·∫øu l√† c√¢u h·ªèi chung kh√¥ng li√™n quan ƒë·∫øn t√†i li·ªáu
      const isGeneralQuestion = this.contentClassifier.isGeneralQuestion(question);
      if (isGeneralQuestion && !question.toLowerCase().includes('c√¥ng ty') && !question.toLowerCase().includes('t√†i li·ªáu')) {
        console.log(`‚ÑπÔ∏è Detected general knowledge question`);
        return {
          intent: 'general_question',
          source: 'constraints',
          topic: 'general_knowledge',
          company: null,
          department: null,
          confidence: 85,
          sessionContext: sessionContext,
          error: null
        };
      }
      
      // Ph√¢n t√≠ch intent v√† ch·ªß ƒë·ªÅ c·ªßa c√¢u h·ªèi
      const intentAnalysis = await this.analyzeQuestionIntent(question);
      
      // Ph√°t hi·ªán ph√≤ng ban li√™n quan
      const department = this.detectDepartment(question);
      
      // X√°c ƒë·ªãnh ngu·ªìn d·ªØ li·ªáu ph√π h·ª£p
      const source = this.determineDataSource(intentAnalysis, question);
      
      return {
        intent: intentAnalysis.intent,
        source: source,
        topic: intentAnalysis.category,
        company: intentAnalysis.company,
        department: department,
        confidence: intentAnalysis.confidence,
        sessionContext: sessionContext,
        error: null
      };
    } catch (error) {
      console.error('Error analyzing question:', error);
      return {
        intent: 'general_question',
        source: 'constraints',
        topic: null,
        company: null,
        department: null,
        confidence: 30,
        sessionContext: {},
        error: 'L·ªói khi ph√¢n t√≠ch c√¢u h·ªèi'
      };
    }
  }
  
  /**
   * Ph√¢n t√≠ch intent c·ªßa c√¢u h·ªèi
   * @param {string} question - C√¢u h·ªèi c·∫ßn ph√¢n t√≠ch
   * @returns {Object} K·∫øt qu·∫£ ph√¢n t√≠ch intent
   */
  async analyzeQuestionIntent(question) {
    try {
      // Ki·ªÉm tra tr∆∞·ªõc b·∫±ng c√°c pattern ƒë·∫∑c bi·ªát
      const questionLower = question.toLowerCase();
      
      // Pattern cho danh s√°ch t√†i li·ªáu
      if (/(danh s√°ch|list|li·ªát k√™|show|hi·ªÉn th·ªã|xem).*(t√†i li·ªáu|document|file|vƒÉn b·∫£n|quy ƒë·ªãnh|quy tr√¨nh)/i.test(questionLower)) {
        const company = this.extractCompanyFromQuestion(question);
        return {
          intent: 'list_documents',
          target: 'documents',
          company: company,
          category: null,
          confidence: 90
        };
      }
      
      // Pattern cho danh s√°ch c√¥ng ty
      if (/(danh s√°ch|list|li·ªát k√™|show|hi·ªÉn th·ªã|xem).*(c√¥ng ty|company|t·∫≠p ƒëo√†n|group)/i.test(questionLower)) {
        return {
          intent: 'list_companies',
          target: 'knowledge',
          company: null,
          category: null,
          confidence: 90
        };
      }
      
      const analysisPrompt = `
Ph√¢n t√≠ch c√¢u h·ªèi sau ƒë√¢y v√† tr·∫£ v·ªÅ JSON format v·ªõi c√°c th√¥ng tin:

C√¢u h·ªèi: "${question}"

H√£y ph√¢n t√≠ch:
1. INTENT: Ng∆∞·ªùi d√πng mu·ªën g√¨? (list_companies, list_documents, find_knowledge, hybrid_search, general_question)
2. TARGET: T√¨m g√¨? (documents, knowledge, both)  
3. COMPANY: C√¥ng ty n√†o? (PDH, PDI, PDE, PDHOS, RHS, ho·∫∑c null)
4. CATEGORY: Lo·∫°i th√¥ng tin? (IT, HR, Finance, Legal, Operations, ho·∫∑c null)
5. CONFIDENCE: ƒê·ªô tin c·∫≠y (0-100)

C√°c INTENT types:
- list_companies: Mu·ªën xem danh s√°ch c√°c c√¥ng ty trong t·∫≠p ƒëo√†n
- list_documents: Mu·ªën xem danh s√°ch, li·ªát k√™ t√†i li·ªáu/file
- find_knowledge: H·ªèi v·ªÅ th√¥ng tin c·ª• th·ªÉ ƒë√£ h·ªçc (nh√¢n s·ª±, quy tr√¨nh...)
- hybrid_search: C·∫ßn t√¨m trong c·∫£ documents + knowledge 
- general_question: C√¢u h·ªèi chung chung

C√°c t·ª´ kh√≥a ch·ªâ hybrid_search:
- "t√≥m t·∫Øt", "gi·∫£i th√≠ch", "m√¥ t·∫£", "chi ti·∫øt v·ªÅ"
- "quy tr√¨nh", "quy ƒë·ªãnh", "ch√≠nh s√°ch", "h∆∞·ªõng d·∫´n"
- "n·ªôi dung", "th√¥ng tin trong", "theo t√†i li·ªáu"
- "h·ªá th·ªëng", "c∆° ch·∫ø", "c√°ch th·ª©c"

C√°c t·ª´ kh√≥a ch·ªâ list_documents:
- "danh s√°ch t√†i li·ªáu", "li·ªát k√™ t√†i li·ªáu", "li·ªát k√™ file"
- "t√†i li·ªáu thu·ªôc", "t√†i li·ªáu c·ªßa", "t√†i li·ªáu li√™n quan ƒë·∫øn"
- "xem t√†i li·ªáu c·ªßa", "hi·ªÉn th·ªã t√†i li·ªáu"

Ch·ªâ tr·∫£ v·ªÅ JSON, kh√¥ng gi·∫£i th√≠ch:`;

      const result = await this.model.generateContent(analysisPrompt);
      const response = result.response;
      const text = response.text();
      
      // Extract JSON from response
      console.log(`üß† Raw AI response:`, text);
      
      // Try to find JSON in the response
      let analysis = null;
      
      // First try: Find complete JSON object
      const jsonMatch = text.match(/\{[^{}]*\}/);
      if (jsonMatch) {
        try {
          analysis = JSON.parse(jsonMatch[0]);
          console.log(`üß† AI Intent Analysis:`, analysis);
          return analysis;
        } catch (parseError) {
          console.error('JSON parse error:', parseError);
        }
      }
      
      // Second try: Extract key-value pairs manually
      const intentMatch = text.match(/"intent"\s*:\s*"([^"]+)"/);
      const targetMatch = text.match(/"target"\s*:\s*"([^"]+)"/);
      const companyMatch = text.match(/"company"\s*:\s*"?([^",}]+)"?/);
      const categoryMatch = text.match(/"category"\s*:\s*"?([^",}]+)"?/);
      const confidenceMatch = text.match(/"confidence"\s*:\s*(\d+)/);
      
      if (intentMatch) {
        analysis = {
          intent: intentMatch[1],
          target: targetMatch ? targetMatch[1] : 'both',
          company: companyMatch ? companyMatch[1] : null,
          category: categoryMatch ? categoryMatch[1] : null,
          confidence: confidenceMatch ? parseInt(confidenceMatch[1]) : 70
        };
        console.log(`üß† Manually parsed intent:`, analysis);
        return analysis;
      }
      
      // Fallback to basic analysis
      return {
        intent: 'general_question',
        target: 'both', 
        company: this.extractCompanyFromQuestion(question),
        category: null,
        confidence: 50
      };
      
    } catch (error) {
      console.error('Error in intent analysis:', error);
      // Fallback to basic logic
      return {
        intent: 'general_question',
        target: 'both',
        company: this.extractCompanyFromQuestion(question),
        category: null,
        confidence: 30
      };
    }
  }
  
  /**
   * Ph√°t hi·ªán ph√≤ng ban t·ª´ c√¢u h·ªèi
   * @param {string} question - C√¢u h·ªèi c·∫ßn ph√¢n t√≠ch
   * @returns {string|null} T√™n ph√≤ng ban ho·∫∑c null
   */
  detectDepartment(question) {
    const questionLower = question.toLowerCase();
    
    // C√°c t·ª´ kh√≥a ph√≤ng ban
    const departmentKeywords = {
      'it': ['it', 'c√¥ng ngh·ªá th√¥ng tin', 'cntt', 'ph√≤ng it', 'ban it', 'technology'],
      'hr': ['hr', 'nh√¢n s·ª±', 'human resource', 'ph√≤ng nh√¢n s·ª±', 'ban nh√¢n s·ª±', 'tuy·ªÉn d·ª•ng'],
      'finance': ['t√†i ch√≠nh', 'finance', 'k·∫ø to√°n', 'accounting', 'ph√≤ng t√†i ch√≠nh', 'ban t√†i ch√≠nh'],
      'legal': ['ph√°p ch·∫ø', 'legal', 'ph√°p l√Ω', 'ph√≤ng ph√°p ch·∫ø', 'ban ph√°p ch·∫ø'],
      'operations': ['v·∫≠n h√†nh', 'operations', 'ph√≤ng v·∫≠n h√†nh', 'ban v·∫≠n h√†nh'],
      'sales': ['kinh doanh', 'sales', 'b√°n h√†ng', 'ph√≤ng kinh doanh', 'ban kinh doanh'],
      'marketing': ['marketing', 'ti·∫øp th·ªã', 'ph√≤ng marketing', 'ban marketing']
    };
    
    // Ki·ªÉm tra t·ª´ng ph√≤ng ban
    for (const [dept, keywords] of Object.entries(departmentKeywords)) {
      for (const keyword of keywords) {
        if (questionLower.includes(keyword)) {
          return dept;
        }
      }
    }
    
    return null;
  }
  
  /**
   * X√°c ƒë·ªãnh ngu·ªìn d·ªØ li·ªáu ph√π h·ª£p cho c√¢u h·ªèi
   * @param {Object} intentAnalysis - K·∫øt qu·∫£ ph√¢n t√≠ch intent
   * @param {string} question - C√¢u h·ªèi g·ªëc
   * @returns {string} Ngu·ªìn d·ªØ li·ªáu (documents, knowledge, constraints, hybrid)
   */
  determineDataSource(intentAnalysis, question) {
    // Ki·ªÉm tra c√¢u h·ªèi chung chung
    if (this.contentClassifier.isGeneralQuestion(question)) {
      return 'constraints';
    }
    
    // X√°c ƒë·ªãnh ngu·ªìn d·ªØ li·ªáu d·ª±a tr√™n intent
    switch (intentAnalysis.intent) {
      case 'list_documents':
        return 'documents';
      
      case 'list_companies':
        return 'knowledge';
      
      case 'find_knowledge':
        return 'knowledge';
      
      case 'hybrid_search':
        return 'hybrid';
      
      case 'general_question':
        return 'constraints';
      
      default:
        // Ph√¢n t√≠ch c√¢u h·ªèi ƒë·ªÉ x√°c ƒë·ªãnh n·∫øu c·∫ßn hybrid search
        const hybridKeywords = [
          't√≥m t·∫Øt', 'summary', 'gi·∫£i th√≠ch', 'explain', 'm√¥ t·∫£', 'describe',
          'chi ti·∫øt', 'detail', 'n·ªôi dung', 'content', 't√†i li·ªáu n√†o', 'which document',
          'h∆∞·ªõng d·∫´n', 'guide', 'instructions'
        ];
        
        const questionLower = question.toLowerCase();
        const needsHybridSearch = hybridKeywords.some(keyword => questionLower.includes(keyword));
        
        return needsHybridSearch ? 'hybrid' : 'documents';
    }
  }

  /**
   * Tr√≠ch xu·∫•t t√™n c√¥ng ty t·ª´ c√¢u h·ªèi
   * @param {string} question - C√¢u h·ªèi c·∫ßn ph√¢n t√≠ch
   * @returns {string|null} T√™n c√¥ng ty ho·∫∑c null
   */
  extractCompanyFromQuestion(question) {
    try {
      // Danh s√°ch c√°c m√£ c√¥ng ty
      const companyPatterns = [
        { pattern: /\b(pdh|ph√°t ƒë·∫°t holdings|phat dat holdings)\b/i, code: 'PDH' },
        { pattern: /\b(pdi|ph√°t ƒë·∫°t invest|phat dat invest)\b/i, code: 'PDI' },
        { pattern: /\b(pde|ph√°t ƒë·∫°t edu|phat dat edu|ph√°t ƒë·∫°t education)\b/i, code: 'PDE' },
        { pattern: /\b(pdhos|ph√°t ƒë·∫°t hospital|phat dat hospital|ph√°t ƒë·∫°t b·ªánh vi·ªán)\b/i, code: 'PDHOS' },
        { pattern: /\b(rhs|roman hospital|b·ªánh vi·ªán roman)\b/i, code: 'RHS' }
      ];
      
      const questionLower = question.toLowerCase();
      
      // T√¨m c√¥ng ty trong c√¢u h·ªèi
      for (const company of companyPatterns) {
        if (company.pattern.test(questionLower)) {
          return company.code;
        }
      }
      
      // Ki·ªÉm tra chu·ªói ƒë∆∞·ª£c b·ªçc trong d·∫•u ngo·∫∑c - c√≥ th·ªÉ l√† m√£ c√¥ng ty
      const bracketMatch = question.match(/\(([A-Z0-9]{3,6})\)/);
      if (bracketMatch) {
        const possibleCompanyCode = bracketMatch[1];
        const validCompanyCodes = ['PDH', 'PDI', 'PDE', 'PDHOS', 'RHS'];
        if (validCompanyCodes.includes(possibleCompanyCode)) {
          return possibleCompanyCode;
        }
      }
      
      return null;
    } catch (error) {
      console.error('Error extracting company:', error);
      return null;
    }
  }

  /**
   * Ph√°t hi·ªán t√™n t√†i li·ªáu c·ª• th·ªÉ trong c√¢u h·ªèi
   * @param {string} question - C√¢u h·ªèi c·∫ßn ph√¢n t√≠ch
   * @returns {boolean} C√≥ ph√°t hi·ªán t√™n t√†i li·ªáu c·ª• th·ªÉ hay kh√¥ng
   */
  detectSpecificDocument(question) {
    // Ki·ªÉm tra c√°c ƒë·ªãnh d·∫°ng t√†i li·ªáu c·ª• th·ªÉ
    const documentPatterns = [
      /\b[A-Z0-9]{2,10}-[A-Z0-9]{2,10}(-[A-Z0-9]{2,10})*\b/, // M√£ t√†i li·ªáu: QT-NS-01
      /\b\w+\.(pdf|docx?|xlsx?|pptx?|txt)\b/i, // T√™n file v·ªõi extension
      /"([^"]+\.(pdf|doc|docx|xls|xlsx|ppt|pptx|txt))"/i, // T√™n file trong d·∫•u ngo·∫∑c k√©p
      /'([^']+\.(pdf|doc|docx|xls|xlsx|ppt|pptx|txt))'/i, // T√™n file trong d·∫•u ngo·∫∑c ƒë∆°n
      /\b(quy tr√¨nh|quy ƒë·ªãnh|ch√≠nh s√°ch|h∆∞·ªõng d·∫´n|s∆° ƒë·ªì|bi·ªÉu m·∫´u) [a-zA-Z0-9\s]{3,30}\b/i, // "quy tr√¨nh l√†m vi·ªác"
      /\b(process|policy|procedure|guideline|form|template) [a-zA-Z0-9\s]{3,30}\b/i // "leave policy"
    ];
    
    return documentPatterns.some(pattern => pattern.test(question));
  }
  
  /**
   * Ph√°t hi·ªán ch·ªß ƒë·ªÅ t·ª´ c√¢u h·ªèi
   * @param {string} question - C√¢u h·ªèi c·∫ßn ph√¢n t√≠ch
   * @returns {string|null} Ch·ªß ƒë·ªÅ ho·∫∑c null
   */
  detectTopic(question) {
    const questionLower = question.toLowerCase();
    
    // T·ª´ kh√≥a theo ch·ªß ƒë·ªÅ
    const topicKeywords = {
      'hr': [
        'nh√¢n s·ª±', 'human resources', 'hr', 'tuy·ªÉn d·ª•ng', 'recruitment',
        'ngh·ªâ ph√©p', 'leave', 'ƒë√†o t·∫°o', 'training', 'l∆∞∆°ng', 'salary',
        'th∆∞·ªüng', 'bonus', 'ph√∫c l·ª£i', 'benefits', 'nh√¢n vi√™n', 'employee',
        'ƒë√°nh gi√°', 'evaluation', 'k·ª∑ lu·∫≠t', 'discipline', 'vƒÉn h√≥a', 'culture'
      ],
      'finance': [
        't√†i ch√≠nh', 'finance', 'k·∫ø to√°n', 'accounting', 'chi ph√≠', 'expense',
        'ng√¢n s√°ch', 'budget', 'l∆∞∆°ng', 'salary', 'thu·∫ø', 'tax', 'doanh thu', 'revenue',
        'b√°o c√°o t√†i ch√≠nh', 'financial report', 'chi ti√™u', 'spending',
        'thanh to√°n', 'payment', 'h√≥a ƒë∆°n', 'invoice'
      ],
      'legal': [
        'ph√°p ch·∫ø', 'legal', 'lu·∫≠t', 'law', 'h·ª£p ƒë·ªìng', 'contract',
        'th·ªèa thu·∫≠n', 'agreement', 'b·∫£n ghi nh·ªõ', 'mou', 'tu√¢n th·ªß', 'compliance',
        'tranh ch·∫•p', 'dispute', 'ki·ªán t·ª•ng', 'litigation', 's·ªü h·ªØu tr√≠ tu·ªá', 'ip'
      ],
      'operations': [
        'v·∫≠n h√†nh', 'operations', 'quy tr√¨nh', 'process', 'sop', 'workflow',
        'chu·ªói cung ·ª©ng', 'supply chain', 'logistics', 'v·∫≠n chuy·ªÉn', 'shipping',
        's·∫£n xu·∫•t', 'production', 'ch·∫•t l∆∞·ª£ng', 'quality', 'b·∫£o tr√¨', 'maintenance'
      ],
      'it': [
        'it', 'c√¥ng ngh·ªá th√¥ng tin', 'cntt', 'ph·∫ßn m·ªÅm', 'software',
        'ph·∫ßn c·ª©ng', 'hardware', 'h·ªá th·ªëng', 'system', 'm·∫°ng', 'network',
        'b·∫£o m·∫≠t', 'security', 'd·ªØ li·ªáu', 'data', '·ª©ng d·ª•ng', 'application'
      ],
      'marketing': [
        'marketing', 'ti·∫øp th·ªã', 'qu·∫£ng c√°o', 'advertising', 'branding', 'th∆∞∆°ng hi·ªáu',
        'chi·∫øn d·ªãch', 'campaign', 'truy·ªÅn th√¥ng', 'communication', 'pr', 'qu·∫£ng b√°',
        'kh√°ch h√†ng', 'customer', 'th·ªã tr∆∞·ªùng', 'market', 'seo', 'sem'
      ],
      'sales': [
        'kinh doanh', 'sales', 'b√°n h√†ng', 'selling', 'kh√°ch h√†ng', 'customer',
        'doanh s·ªë', 'revenue', 'target', 'm·ª•c ti√™u', 'commission', 'hoa h·ªìng',
        'ƒë·ªëi t√°c', 'partner', 'h·ª£p ƒë·ªìng', 'contract', 'b2b', 'b2c'
      ],
      'general': [
        'c√¥ng ty', 'company', 't·ªï ch·ª©c', 'organization', 'chung', 'general',
        'n·ªôi quy', 'rules', 'quy ƒë·ªãnh', 'regulations', 'ch√≠nh s√°ch', 'policy'
      ]
    };
    
    // Ph√°t hi·ªán ch·ªß ƒë·ªÅ theo t·ª´ kh√≥a
    for (const [topic, keywords] of Object.entries(topicKeywords)) {
      for (const keyword of keywords) {
        if (questionLower.includes(keyword)) {
          return topic;
        }
      }
    }
    
    // Tr√≠ch xu·∫•t ch·ªß ƒë·ªÅ t·ª´ m√£ t√†i li·ªáu (VD: QT-NS-01 -> hr, QT-TC-02 -> finance)
    const docCodeMatch = question.match(/\b([A-Z]{2,3})-([A-Z]{2,3})-\d+\b/);
    if (docCodeMatch) {
      const deptCode = docCodeMatch[2].toUpperCase();
      const deptMapping = {
        'NS': 'hr',
        'TC': 'finance',
        'PC': 'legal',
        'VH': 'operations',
        'IT': 'it',
        'MKT': 'marketing',
        'KD': 'sales',
        'QT': 'general'
      };
      
      if (deptMapping[deptCode]) {
        return deptMapping[deptCode];
      }
    }
    
    return null;
  }

  /**
   * L·∫•y ng·ªØ c·∫£nh phi√™n h·ªôi tho·∫°i
   * @param {string} sessionId - ID phi√™n h·ªôi tho·∫°i
   * @returns {Object} Ng·ªØ c·∫£nh phi√™n
   */
  async getSessionContext(sessionId) {
    try {
      const { pool } = require('../../config/database');
      
      // Get conversation context
      const sessionQuery = await pool.query(
        'SELECT context FROM conversations WHERE session_id = $1 AND is_active = true',
        [sessionId]
      );
      
      if (sessionQuery.rows.length > 0) {
        return sessionQuery.rows[0].context || {};
      }
      
      return {};
    } catch (error) {
      console.error('Error getting session context:', error);
      return {};
    }
  }
}

module.exports = QuestionAnalysisService; 
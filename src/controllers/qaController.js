const { db } = require('../../database');
const geminiService = require('../../services/gemini');
const ConversationService = require('../services/conversation/conversationService');
const QuestionAnalysisService = require('../services/ai/questionAnalysisService');
const DataIntegrationService = require('../services/ai/dataIntegrationService');
const ContentClassifier = require('../utils/content/contentClassifier');
const documentRepository = require('../repositories/documentRepository');

const conversationService = new ConversationService();
const questionAnalysisService = new QuestionAnalysisService();
const dataIntegrationService = new DataIntegrationService();
const contentClassifier = new ContentClassifier();

// Ask question with conversation context
const askQuestion = async (req, res) => {
  try {
    const { question, sessionId, userId } = req.body;
    const startTime = Date.now();

    if (!question || question.trim().length === 0) {
      return res.status(400).json({ success: false, error: 'Question is required' });
    }

    console.log(`üó£Ô∏è Processing question with session: ${sessionId || 'new'}`);

    // Get or create conversation session
    const session = await conversationService.getOrCreateSession(sessionId || null, userId);
    const actualSessionId = session.session_id;

    // Save the question to conversation history FIRST
    const savedQuestion = await conversationService.saveMessage(actualSessionId, 'question', question.trim());
    if (!savedQuestion) {
      throw new Error(`Failed to save question to session ${actualSessionId}`);
    }

    // Ki·ªÉm tra n·ªôi dung nh·∫°y c·∫£m
    const isSensitive = await contentClassifier.isSensitiveContent(question);
    if (isSensitive) {
      const answer = `‚ö†Ô∏è C√¢u h·ªèi c·ªßa b·∫°n c√≥ th·ªÉ ch·ª©a n·ªôi dung nh·∫°y c·∫£m ho·∫∑c kh√¥ng ph√π h·ª£p v·ªõi ch√≠nh s√°ch c·ªßa h·ªá th·ªëng. Vui l√≤ng ƒë·∫∑t c√¢u h·ªèi kh√°c ho·∫∑c li√™n h·ªá qu·∫£n tr·ªã vi√™n n·∫øu b·∫°n cho r·∫±ng ƒë√¢y l√† l·ªói.`;
      
      await conversationService.saveMessage(actualSessionId, 'answer', answer, [], { 
        isSensitive: true,
        originalQuestion: question.trim()
      });

      return res.json({
        success: true,
        sessionId: actualSessionId,
        question: question.trim(),
        answer,
        relevantDocuments: [],
        responseTime: Date.now() - startTime,
        contextInfo: {
          isSensitive: true
        }
      });
    }

    // Then resolve references (which needs the history)
    const referenceResolution = await conversationService.resolveReferences(actualSessionId, question.trim());
    
    if (referenceResolution.error) {
      // Return helpful error message for unresolved references
      const answer = `‚ùì ${referenceResolution.error}\n\nüí° *H√£y h·ªèi c·ª• th·ªÉ t√™n t√†i li·ªáu ƒë·ªÉ t√¥i c√≥ th·ªÉ tr·∫£ l·ªùi ch√≠nh x√°c.*`;
      
      await conversationService.saveMessage(actualSessionId, 'answer', answer, [], { 
        hasReferenceError: true,
        originalQuestion: question.trim(),
        referenceAnalysis: referenceResolution.analysis || {}
      });

      return res.json({
        success: true,
        sessionId: actualSessionId,
        question: question.trim(),
        answer,
        relevantDocuments: [],
        responseTime: Date.now() - startTime,
        contextInfo: {
          hasReference: referenceResolution.hasReference,
          resolved: false,
          error: referenceResolution.error,
          referenceAnalysis: referenceResolution.analysis || {}
        }
      });
    }

    // Use resolved question for processing
    const processQuestion = referenceResolution.resolvedQuestion;
    console.log(`üîó Using question: "${processQuestion}"`);
    
    // Ghi log th√¥ng tin ph√¢n t√≠ch tham chi·∫øu n·∫øu c√≥
    if (referenceResolution.hasReference && referenceResolution.analysis) {
      console.log(`üîç Ph√¢n t√≠ch tham chi·∫øu:`);
      console.log(`   - Lo·∫°i tham chi·∫øu: ${referenceResolution.analysis.referenceType || 'N/A'}`);
      console.log(`   - ƒê·ªô tin c·∫≠y: ${referenceResolution.analysis.confidence || 0}%`);
      console.log(`   - Gi·∫£i th√≠ch: ${referenceResolution.analysis.explanation || 'N/A'}`);
    }

    // Ph√¢n t√≠ch c√¢u h·ªèi ƒë·ªÉ x√°c ƒë·ªãnh intent, ch·ªß ƒë·ªÅ v√† ngu·ªìn d·ªØ li·ªáu
    const questionAnalysis = await questionAnalysisService.analyzeQuestion(processQuestion, actualSessionId);
    console.log(`üìä Question analysis:`, JSON.stringify(questionAnalysis));
    
    // X·ª≠ l√Ω n·∫øu ph√°t hi·ªán n·ªôi dung nh·∫°y c·∫£m t·ª´ ph√¢n t√≠ch
    if (questionAnalysis.intent === 'sensitive_content') {
      const answer = `‚ö†Ô∏è C√¢u h·ªèi c·ªßa b·∫°n c√≥ th·ªÉ ch·ª©a n·ªôi dung nh·∫°y c·∫£m ho·∫∑c kh√¥ng ph√π h·ª£p v·ªõi ch√≠nh s√°ch c·ªßa h·ªá th·ªëng. Vui l√≤ng ƒë·∫∑t c√¢u h·ªèi kh√°c ho·∫∑c li√™n h·ªá qu·∫£n tr·ªã vi√™n n·∫øu b·∫°n cho r·∫±ng ƒë√¢y l√† l·ªói.`;
      
      await conversationService.saveMessage(actualSessionId, 'answer', answer, [], { 
        isSensitive: true,
        originalQuestion: question.trim()
      });

      return res.json({
        success: true,
        sessionId: actualSessionId,
        question: question.trim(),
        answer,
        relevantDocuments: [],
        responseTime: Date.now() - startTime,
        contextInfo: {
          isSensitive: true
        }
      });
    }
    
    // H·ª£p nh·∫•t d·ªØ li·ªáu t·ª´ nhi·ªÅu ngu·ªìn
    const integratedData = await dataIntegrationService.integrateData(processQuestion, questionAnalysis);

    // N·∫øu l√† intent list_documents, l∆∞u danh s√°ch documentId v√†o session context
    if (questionAnalysis.intent === 'list_documents' && integratedData.documents && integratedData.documents.length > 0) {
      // L∆∞u m·∫£ng id t√†i li·ªáu v√†o context
      const documentIdList = integratedData.documents.map(doc => doc.id);
      const documentNames = integratedData.documents.map(doc => ({
        id: doc.id,
        name: doc.dc_title || doc.original_name || 'T√†i li·ªáu kh√¥ng t√™n',
        type: doc.dc_type || doc.category || 'Ch∆∞a ph√¢n lo·∫°i'
      }));
      
      await conversationService.updateSessionContext(actualSessionId, { 
        lastDocumentList: documentIdList,
        lastDocuments: documentNames,
        lastIntent: 'list_documents'
      });
      
      console.log(`üìù Saved ${documentIdList.length} documents to session context`);
    }
    
    // X·ª≠ l√Ω c√¢u h·ªèi v·ªõi d·ªØ li·ªáu ƒë√£ h·ª£p nh·∫•t
    let result;
    
    // N·∫øu c√≥ constraint ph√π h·ª£p, s·ª≠ d·ª•ng n√≥
    if (integratedData.constraint) {
      result = {
        answer: integratedData.constraint.answer,
        relevantDocuments: [],
        responseTime: Date.now() - startTime
      };
    }
    // N·∫øu kh√¥ng c√≥ constraint, x·ª≠ l√Ω theo ngu·ªìn d·ªØ li·ªáu
    else {
      // ∆Øu ti√™n s·ª≠ d·ª•ng geminiService.askQuestion n·∫øu c√≥ t√†i li·ªáu ho·∫∑c knowledge entries
      if (integratedData.documents.length > 0 || integratedData.knowledgeEntries.length > 0) {
        result = await geminiService.askQuestion(processQuestion, {
          documents: integratedData.documents,
          knowledgeEntries: integratedData.knowledgeEntries,
          companyInfo: integratedData.companyInfo,
          departmentInfo: integratedData.departmentInfo,
          analysisResult: questionAnalysis
        });
      }
      // N·∫øu kh√¥ng c√≥ d·ªØ li·ªáu, x·ª≠ l√Ω nh∆∞ c√¢u h·ªèi chung
      else {
        result = await geminiService.askQuestion(processQuestion);
      }
    }

    // B·ªï sung metadata v·ªÅ ph√¢n t√≠ch c√¢u h·ªèi v√†o k·∫øt qu·∫£
    result.analysisResult = questionAnalysis;
    
    // L∆∞u th√¥ng tin v·ªÅ ngu·ªìn d·ªØ li·ªáu ƒë√£ s·ª≠ d·ª•ng
    const metadata = {
      responseTime: result.responseTime || (Date.now() - startTime),
      originalQuestion: question.trim(),
      resolvedQuestion: processQuestion,
      hasReference: referenceResolution.hasReference,
      analysisResult: questionAnalysis,
      dataSources: integratedData.metadata?.sources || [],
      referenceAnalysis: referenceResolution.analysis || {},
      documents: integratedData.documents || [],
      contextInfo: {
        hasReference: referenceResolution.hasReference,
        resolved: referenceResolution.hasReference && !referenceResolution.error,
        referencedDocuments: referenceResolution.referencedDocuments || [],
        analysisResult: questionAnalysis,
        dataSources: integratedData.metadata?.sources || [],
        referenceAnalysis: referenceResolution.analysis || {}
      }
    };

    // L∆∞u th√¥ng tin t√†i li·ªáu li√™n quan v√†o session context
    if (result.relevantDocuments && result.relevantDocuments.length > 0) {
      await conversationService.updateSessionContext(actualSessionId, { 
        lastRelevantDocuments: result.relevantDocuments,
        lastQuestion: question.trim()
      });
      
      console.log(`üìù Saved ${result.relevantDocuments.length} relevant documents to session context`);
    }

    // X·ª≠ l√Ω t√¨m ki·∫øm t√†i li·ªáu li√™n quan ƒë·∫øn t√≥m t·∫Øt n·∫øu c√≥
    const documentSummaryRequest = processQuestion.toLowerCase().includes('t√≥m t·∫Øt') && 
                                   (processQuestion.toLowerCase().includes('t√†i li·ªáu') || 
                                    processQuestion.toLowerCase().includes('document') || 
                                    processQuestion.toLowerCase().includes('s∆° ƒë·ªì'));
    
    // T√¨m ki·∫øm t√†i li·ªáu ph√π h·ª£p theo t√™n n·∫øu y√™u c·∫ßu t√≥m t·∫Øt
    let documentToSummarize = null;
    if (documentSummaryRequest) {
      // L·∫•y t·ª´ kh√≥a ch√≠nh t·ª´ c√¢u h·ªèi (lo·∫°i b·ªè "t√≥m t·∫Øt", "t√†i li·ªáu" v√† c√°c t·ª´ ph·ªï bi·∫øn)
      const keyTerms = processQuestion.toLowerCase()
        .replace(/t√≥m t·∫Øt|t√†i li·ªáu|document|s∆° ƒë·ªì|c·ªßa|v·ªÅ|l√† g√¨|cho t√¥i|xem/g, '')
        .trim()
        .split(/\s+/)
        .filter(term => term.length > 1);
      
      // N·∫øu c√≥ t·ª´ kh√≥a h·ª£p l·ªá, t√¨m ki·∫øm trong repository
      if (keyTerms.length > 0) {
        try {
          // T√¨m ki·∫øm tr·ª±c ti·∫øp t·ª´ document repository tr∆∞·ªõc
          // L·∫•y pattern t√¨m ki·∫øm t·ª´ c√¢u h·ªèi (v√≠ d·ª•: n·∫øu c√≥ s·ªë th·ª© t·ª±, t√™n file c·ª• th·ªÉ)
          const filePattern = processQuestion.match(/["']([^"']+\.(pdf|docx?|xlsx?|pptx?|txt))["']/i)?.[1] || 
                              processQuestion.match(/(\d+\.\s*[^.,;]+\.(pdf|docx?|xlsx?|pptx?|txt))/i)?.[1] ||
                              null;
          
          let documents = [];
          
          // N·∫øu c√≥ t√™n file c·ª• th·ªÉ, ∆∞u ti√™n t√¨m theo t√™n
          if (filePattern) {
            console.log(`üîç T√¨m t√†i li·ªáu theo pattern: ${filePattern}`);
            documents = await documentRepository.searchDocumentsByName(filePattern);
          } 
          
          // N·∫øu kh√¥ng c√≥ k·∫øt qu·∫£, t√¨m theo t·ª´ kh√≥a
          if (!documents || documents.length === 0) {
            const searchQuery = keyTerms.join(' ');
            console.log(`üîç T√¨m t√†i li·ªáu theo t·ª´ kh√≥a: ${searchQuery}`);
            documents = await documentRepository.searchDocuments(searchQuery);
          }
          
          if (documents && documents.length > 0) {
            // L·∫•y t√†i li·ªáu ph√π h·ª£p nh·∫•t
            documentToSummarize = documents[0];
            console.log(`üìÑ ƒê√£ t√¨m th·∫•y t√†i li·ªáu: ${documentToSummarize.original_name || documentToSummarize.name}`);
          }
        } catch (error) {
          console.error('Error searching for document:', error);
        }
      }
      
      // Backup: N·∫øu kh√¥ng t√¨m th·∫•y t·ª´ repository, th·ª≠ t√¨m trong integratedData
      if (!documentToSummarize && integratedData.documents && integratedData.documents.length > 0) {
        documentToSummarize = integratedData.documents.find(doc => {
          const docName = doc.original_name ? doc.original_name.toLowerCase() : 
                        (doc.name ? doc.name.toLowerCase() : '');
          return keyTerms.some(term => docName.includes(term));
        });
      }
      
      // N·∫øu t√¨m th·∫•y t√†i li·ªáu ph√π h·ª£p
      if (documentToSummarize) {
        // T·∫°o t√≥m t·∫Øt t·ª´ metadata
        const documentSummary = `Th√¥ng tin t√†i li·ªáu "${documentToSummarize.original_name || documentToSummarize.name}":
- Lo·∫°i t√†i li·ªáu: ${documentToSummarize.category || documentToSummarize.type || 'Kh√¥ng c√≥ th√¥ng tin'}
- ID: ${documentToSummarize.id}
${documentToSummarize.page_count ? `- S·ªë trang: ${documentToSummarize.page_count}\n` : ''}
${documentToSummarize.file_size ? `- Dung l∆∞·ª£ng: ${documentToSummarize.file_size} bytes\n` : ''}
${documentToSummarize.metadata && documentToSummarize.metadata.description ? `- M√¥ t·∫£: ${documentToSummarize.metadata.description}\n` : ''}
${documentToSummarize.created_at ? `- Ng√†y t·∫°o: ${new Date(documentToSummarize.created_at).toLocaleDateString('vi-VN')}\n` : ''}

${result.answer}`;

        result.answer = documentSummary;
        
        // ƒê·∫£m b·∫£o t√†i li·ªáu n√†y n·∫±m trong relevantDocuments
        if (!result.relevantDocuments) {
          result.relevantDocuments = [];
        }
        if (!result.relevantDocuments.some(doc => doc.id === documentToSummarize.id)) {
          result.relevantDocuments.unshift({
            ...documentToSummarize,
            relevanceScore: 10 // ƒêi·ªÉm cao nh·∫•t v√¨ ƒë√¢y l√† t√†i li·ªáu ƒë∆∞·ª£c y√™u c·∫ßu c·ª• th·ªÉ
          });
        }
      }
    }

    // L∆∞u c√¢u tr·∫£ l·ªùi v√†o l·ªãch s·ª≠ h·ªôi tho·∫°i
    const savedAnswer = await conversationService.saveMessage(
      actualSessionId,
      'answer',
      result.answer,
      result.relevantDocuments || [],
      {
        responseTime: result.responseTime || (Date.now() - startTime),
        originalQuestion: question.trim(),
        resolvedQuestion: processQuestion,
        hasReference: referenceResolution.hasReference,
        analysisResult: questionAnalysis,
        dataSources: integratedData.metadata?.sources || [],
        referenceAnalysis: referenceResolution.analysis || {},
        documents: integratedData.documents || [],
        contextInfo: {
          hasReference: referenceResolution.hasReference,
          resolved: referenceResolution.hasReference && !referenceResolution.error,
          referencedDocuments: referenceResolution.referencedDocuments || [],
          analysisResult: questionAnalysis,
          dataSources: integratedData.metadata?.sources || [],
          referenceAnalysis: referenceResolution.analysis || {}
        }
      }
    );

    // N·∫øu l√† intent document_by_index v√† c√≥ documentId, tr·∫£ v·ªÅ chi ti·∫øt t√†i li·ªáu
    if (questionAnalysis.intent === 'document_by_index' && questionAnalysis.documentId) {
      // L·∫•y chi ti·∫øt t√†i li·ªáu t·ª´ DB
      const docDetail = await documentRepository.getDocumentById(questionAnalysis.documentId);
      if (docDetail) {
        const answer = `Chi ti·∫øt t√†i li·ªáu s·ªë ${questionAnalysis.index + 1}:
- T√™n: ${docDetail.original_name}
- Lo·∫°i: ${docDetail.category}
- Dung l∆∞·ª£ng: ${docDetail.file_size} bytes
- S·ªë trang: ${docDetail.page_count || 'N/A'}
- M√¥ t·∫£: ${docDetail.metadata && docDetail.metadata.description ? docDetail.metadata.description : 'Kh√¥ng c√≥ m√¥ t·∫£.'}`;
        await conversationService.saveMessage(actualSessionId, 'answer', answer, [docDetail], { byIndex: true, documentId: docDetail.id });
        return res.json({
          success: true,
          sessionId: actualSessionId,
          question: question.trim(),
          answer,
          relevantDocuments: [docDetail],
          responseTime: Date.now() - startTime,
          contextInfo: {
            byIndex: true,
            documentId: docDetail.id,
            index: questionAnalysis.index
          }
        });
      } else {
        const answer = `Kh√¥ng t√¨m th·∫•y t√†i li·ªáu theo th·ª© t·ª± y√™u c·∫ßu trong danh s√°ch tr∆∞·ªõc ƒë√≥.`;
        await conversationService.saveMessage(actualSessionId, 'answer', answer, [], { byIndex: true, error: 'Not found' });
        return res.json({
          success: false,
          sessionId: actualSessionId,
          question: question.trim(),
          answer,
          relevantDocuments: [],
          responseTime: Date.now() - startTime,
          contextInfo: {
            byIndex: true,
            error: 'Not found',
            index: questionAnalysis.index
          }
        });
      }
    }

    // Gi·ªõi h·∫°n s·ªë l∆∞·ª£ng relevantDocuments tr·∫£ v·ªÅ (ch·ªâ tr·∫£ v·ªÅ 5 t√†i li·ªáu c√≥ ƒëi·ªÉm li√™n quan cao nh·∫•t)
    let filteredRelevantDocuments = [];
    if (result.relevantDocuments && result.relevantDocuments.length > 0) {
      // S·∫Øp x·∫øp theo ƒëi·ªÉm li√™n quan (relevanceScore) gi·∫£m d·∫ßn v√† ch·ªâ l·∫•y t·ªëi ƒëa 5 t√†i li·ªáu
      filteredRelevantDocuments = result.relevantDocuments
        .sort((a, b) => (b.relevanceScore || 0) - (a.relevanceScore || 0))
        .slice(0, 5);
    }

    res.json({
      success: true,
      sessionId: actualSessionId,
      question: question.trim(),
      answer: result.answer,
      relevantDocuments: filteredRelevantDocuments,
      responseTime: result.responseTime || (Date.now() - startTime),
      contextInfo: {
        hasReference: referenceResolution.hasReference,
        resolved: referenceResolution.hasReference,
        resolvedQuestion: referenceResolution.hasReference ? processQuestion : undefined,
        referencedDocuments: referenceResolution.referencedDocuments || [],
        analysisResult: questionAnalysis,
        dataSources: integratedData.metadata?.sources || [],
        referenceAnalysis: referenceResolution.analysis || {}
      }
    });

  } catch (error) {
    console.error('Error processing question:', error);
    res.status(500).json({ success: false, error: error.message });
  }
};

// Get Q&A history
const getHistory = async (req, res) => {
  try {
    const limit = parseInt(req.query.limit) || 50;
    const questions = await db.getQuestions(limit);
    res.json({ success: true, questions });
  } catch (error) {
    console.error('Error fetching history:', error);
    res.status(500).json({ success: false, error: error.message });
  }
};

// Summarize document
const summarizeDocument = async (req, res) => {
  try {
    const documentId = req.params.id;
    const result = await geminiService.summarizeDocument(documentId);
    res.json({ success: true, summary: result });
  } catch (error) {
    console.error('Error summarizing document:', error);
    res.status(500).json({ success: false, error: error.message });
  }
};

// Extract key information
const extractKeyInfo = async (req, res) => {
  try {
    const { searchTerm } = req.body;
    
    if (!searchTerm || searchTerm.trim().length === 0) {
      return res.status(400).json({ success: false, error: 'Search term is required' });
    }

    const result = await geminiService.extractKeyInfo(searchTerm.trim());
    res.json({ success: true, result });

  } catch (error) {
    console.error('Error extracting key info:', error);
    res.status(500).json({ success: false, error: error.message });
  }
};

// Get conversation history
const getConversationHistory = async (req, res) => {
  try {
    const { sessionId } = req.params;
    const { limit } = req.query;  

    if (!sessionId) {
      return res.status(400).json({ success: false, error: 'Session ID is required' });
    }

    const history = await conversationService.getConversationHistory(sessionId, parseInt(limit) || 10);
    const context = await conversationService.getSessionContext(sessionId);

    res.json({
      success: true,
      sessionId,
      history,
      context,
      totalMessages: history.length
    });

  } catch (error) {
    console.error('Error getting conversation history:', error);
    res.status(500).json({ success: false, error: error.message });
  }
};

// Get conversation statistics
const getConversationStats = async (req, res) => {
  try {
    const { sessionId } = req.params;

    if (!sessionId) {
      return res.status(400).json({ success: false, error: 'Session ID is required' });
    }

    const stats = await conversationService.getConversationStats(sessionId);

    if (!stats) {
      return res.status(404).json({ success: false, error: 'Conversation not found' });
    }

    res.json({
      success: true,
      stats
    });

  } catch (error) {
    console.error('Error getting conversation stats:', error);
    res.status(500).json({ success: false, error: error.message });
  }
};

// End conversation session
const endConversation = async (req, res) => {
  try {
    const { sessionId } = req.params;

    if (!sessionId) {
      return res.status(400).json({ success: false, error: 'Session ID is required' });
    }

    await conversationService.expireSession(sessionId);

    res.json({
      success: true,
      message: 'Conversation ended successfully',
      sessionId
    });

  } catch (error) {
    console.error('Error ending conversation:', error);
    res.status(500).json({ success: false, error: error.message });
  }
};

module.exports = {
  askQuestion,
  getHistory,
  summarizeDocument,
  extractKeyInfo,
  getConversationHistory,
  getConversationStats,
  endConversation
}; 
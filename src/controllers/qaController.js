const { db } = require('../../database');
const geminiService = require('../../services/gemini');
const ConversationService = require('../services/conversation/conversationService');
const QuestionAnalysisService = require('../services/ai/questionAnalysisService');
const DataIntegrationService = require('../services/ai/dataIntegrationService');
const ContentClassifier = require('../utils/content/contentClassifier');
const documentRepository = require('../repositories/documentRepository');

const conversationService = new ConversationService();
const questionAnalysisService = new QuestionAnalysisService();
const dataIntegrationService = new DataIntegrationService();
const contentClassifier = new ContentClassifier();

// Ask question with conversation context
const askQuestion = async (req, res) => {
  try {
    const { question, sessionId, userId } = req.body;
    const startTime = Date.now();

    if (!question || question.trim().length === 0) {
      return res.status(400).json({ success: false, error: 'Question is required' });
    }

    console.log(`üó£Ô∏è Processing question with session: ${sessionId || 'new'}`);

    // Get or create conversation session
    const session = await conversationService.getOrCreateSession(sessionId, userId);
    const actualSessionId = session.session_id;

    // Save the question to conversation history FIRST
    const savedQuestion = await conversationService.saveMessage(actualSessionId, 'question', question.trim());
    if (!savedQuestion) {
      throw new Error(`Failed to save question to session ${actualSessionId}`);
    }

    // Ki·ªÉm tra n·ªôi dung nh·∫°y c·∫£m
    const isSensitive = await contentClassifier.isSensitiveContent(question);
    if (isSensitive) {
      const answer = `‚ö†Ô∏è C√¢u h·ªèi c·ªßa b·∫°n c√≥ th·ªÉ ch·ª©a n·ªôi dung nh·∫°y c·∫£m ho·∫∑c kh√¥ng ph√π h·ª£p v·ªõi ch√≠nh s√°ch c·ªßa h·ªá th·ªëng. Vui l√≤ng ƒë·∫∑t c√¢u h·ªèi kh√°c ho·∫∑c li√™n h·ªá qu·∫£n tr·ªã vi√™n n·∫øu b·∫°n cho r·∫±ng ƒë√¢y l√† l·ªói.`;
      
      await conversationService.saveMessage(actualSessionId, 'answer', answer, [], { 
        isSensitive: true,
        originalQuestion: question.trim()
      });

      return res.json({
        success: true,
        sessionId: actualSessionId,
        question: question.trim(),
        answer,
        relevantDocuments: [],
        responseTime: Date.now() - startTime,
        contextInfo: {
          isSensitive: true
        }
      });
    }

    // Then resolve references (which needs the history)
    const referenceResolution = await conversationService.resolveReferences(actualSessionId, question.trim());
    
    if (referenceResolution.error) {
      // Return helpful error message for unresolved references
      const answer = `‚ùì ${referenceResolution.error}\n\nüí° *H√£y h·ªèi c·ª• th·ªÉ t√™n t√†i li·ªáu ƒë·ªÉ t√¥i c√≥ th·ªÉ tr·∫£ l·ªùi ch√≠nh x√°c.*`;
      
      await conversationService.saveMessage(actualSessionId, 'answer', answer, [], { 
        hasReferenceError: true,
        originalQuestion: question.trim(),
        referenceAnalysis: referenceResolution.analysis || {}
      });

      return res.json({
        success: true,
        sessionId: actualSessionId,
        question: question.trim(),
        answer,
        relevantDocuments: [],
        responseTime: Date.now() - startTime,
        contextInfo: {
          hasReference: referenceResolution.hasReference,
          resolved: false,
          error: referenceResolution.error,
          referenceAnalysis: referenceResolution.analysis || {}
        }
      });
    }

    // Use resolved question for processing
    const processQuestion = referenceResolution.resolvedQuestion;
    console.log(`üîó Using question: "${processQuestion}"`);
    
    // Ghi log th√¥ng tin ph√¢n t√≠ch tham chi·∫øu n·∫øu c√≥
    if (referenceResolution.hasReference && referenceResolution.analysis) {
      console.log(`üîç Ph√¢n t√≠ch tham chi·∫øu:`);
      console.log(`   - Lo·∫°i tham chi·∫øu: ${referenceResolution.analysis.referenceType || 'N/A'}`);
      console.log(`   - ƒê·ªô tin c·∫≠y: ${referenceResolution.analysis.confidence || 0}%`);
      console.log(`   - Gi·∫£i th√≠ch: ${referenceResolution.analysis.explanation || 'N/A'}`);
    }

    // Ph√¢n t√≠ch c√¢u h·ªèi ƒë·ªÉ x√°c ƒë·ªãnh intent, ch·ªß ƒë·ªÅ v√† ngu·ªìn d·ªØ li·ªáu
    const questionAnalysis = await questionAnalysisService.analyzeQuestion(processQuestion, actualSessionId);
    console.log(`üìä Question analysis:`, JSON.stringify(questionAnalysis));
    
    // X·ª≠ l√Ω n·∫øu ph√°t hi·ªán n·ªôi dung nh·∫°y c·∫£m t·ª´ ph√¢n t√≠ch
    if (questionAnalysis.intent === 'sensitive_content') {
      const answer = `‚ö†Ô∏è C√¢u h·ªèi c·ªßa b·∫°n c√≥ th·ªÉ ch·ª©a n·ªôi dung nh·∫°y c·∫£m ho·∫∑c kh√¥ng ph√π h·ª£p v·ªõi ch√≠nh s√°ch c·ªßa h·ªá th·ªëng. Vui l√≤ng ƒë·∫∑t c√¢u h·ªèi kh√°c ho·∫∑c li√™n h·ªá qu·∫£n tr·ªã vi√™n n·∫øu b·∫°n cho r·∫±ng ƒë√¢y l√† l·ªói.`;
      
      await conversationService.saveMessage(actualSessionId, 'answer', answer, [], { 
        isSensitive: true,
        originalQuestion: question.trim()
      });

      return res.json({
        success: true,
        sessionId: actualSessionId,
        question: question.trim(),
        answer,
        relevantDocuments: [],
        responseTime: Date.now() - startTime,
        contextInfo: {
          isSensitive: true
        }
      });
    }
    
    // H·ª£p nh·∫•t d·ªØ li·ªáu t·ª´ nhi·ªÅu ngu·ªìn
    const integratedData = await dataIntegrationService.integrateData(processQuestion, questionAnalysis);

    // N·∫øu l√† intent list_documents, l∆∞u danh s√°ch documentId v√†o session context
    if (questionAnalysis.intent === 'list_documents' && integratedData.documents && integratedData.documents.length > 0) {
      // L∆∞u m·∫£ng id t√†i li·ªáu v√†o context
      const documentIdList = integratedData.documents.map(doc => doc.id);
      await conversationService.updateSessionContext(actualSessionId, { lastDocumentList: documentIdList });
    }
    
    // X·ª≠ l√Ω c√¢u h·ªèi v·ªõi d·ªØ li·ªáu ƒë√£ h·ª£p nh·∫•t
    let result;
    
    // N·∫øu c√≥ constraint ph√π h·ª£p, s·ª≠ d·ª•ng n√≥
    if (integratedData.constraint) {
      result = {
        answer: integratedData.constraint.answer,
        relevantDocuments: [],
        responseTime: Date.now() - startTime
      };
    }
    // N·∫øu kh√¥ng c√≥ constraint, x·ª≠ l√Ω theo ngu·ªìn d·ªØ li·ªáu
    else {
      // ∆Øu ti√™n s·ª≠ d·ª•ng geminiService.askQuestion n·∫øu c√≥ t√†i li·ªáu ho·∫∑c knowledge entries
      if (integratedData.documents.length > 0 || integratedData.knowledgeEntries.length > 0) {
        result = await geminiService.askQuestion(processQuestion, {
          documents: integratedData.documents,
          knowledgeEntries: integratedData.knowledgeEntries,
          companyInfo: integratedData.companyInfo,
          departmentInfo: integratedData.departmentInfo,
          analysisResult: questionAnalysis
        });
      }
      // N·∫øu kh√¥ng c√≥ d·ªØ li·ªáu, x·ª≠ l√Ω nh∆∞ c√¢u h·ªèi chung
      else {
        result = await geminiService.askQuestion(processQuestion);
      }
    }

    // B·ªï sung metadata v·ªÅ ph√¢n t√≠ch c√¢u h·ªèi v√†o k·∫øt qu·∫£
    result.analysisResult = questionAnalysis;
    
    // L∆∞u th√¥ng tin v·ªÅ ngu·ªìn d·ªØ li·ªáu ƒë√£ s·ª≠ d·ª•ng
    const metadata = {
      responseTime: result.responseTime || (Date.now() - startTime),
      originalQuestion: question.trim(),
      resolvedQuestion: processQuestion,
      hasReference: referenceResolution.hasReference,
      analysisResult: questionAnalysis,
      dataSources: integratedData.metadata?.sources || [],
      referenceAnalysis: referenceResolution.analysis || {}
    };

    // Save the answer to conversation history
    await conversationService.saveMessage(
      actualSessionId, 
      'answer', 
      result.answer, 
      result.relevantDocuments || [],
      metadata
    );

    // N·∫øu l√† intent document_by_index v√† c√≥ documentId, tr·∫£ v·ªÅ chi ti·∫øt t√†i li·ªáu
    if (questionAnalysis.intent === 'document_by_index' && questionAnalysis.documentId) {
      // L·∫•y chi ti·∫øt t√†i li·ªáu t·ª´ DB
      const docDetail = await documentRepository.getDocumentById(questionAnalysis.documentId);
      if (docDetail) {
        const answer = `Chi ti·∫øt t√†i li·ªáu s·ªë ${questionAnalysis.index + 1}:
- T√™n: ${docDetail.original_name}
- Lo·∫°i: ${docDetail.category}
- Dung l∆∞·ª£ng: ${docDetail.file_size} bytes
- S·ªë trang: ${docDetail.page_count || 'N/A'}
- M√¥ t·∫£: ${docDetail.metadata && docDetail.metadata.description ? docDetail.metadata.description : 'Kh√¥ng c√≥ m√¥ t·∫£.'}`;
        await conversationService.saveMessage(actualSessionId, 'answer', answer, [docDetail], { byIndex: true, documentId: docDetail.id });
        return res.json({
          success: true,
          sessionId: actualSessionId,
          question: question.trim(),
          answer,
          relevantDocuments: [docDetail],
          responseTime: Date.now() - startTime,
          contextInfo: {
            byIndex: true,
            documentId: docDetail.id,
            index: questionAnalysis.index
          }
        });
      } else {
        const answer = `Kh√¥ng t√¨m th·∫•y t√†i li·ªáu theo th·ª© t·ª± y√™u c·∫ßu trong danh s√°ch tr∆∞·ªõc ƒë√≥.`;
        await conversationService.saveMessage(actualSessionId, 'answer', answer, [], { byIndex: true, error: 'Not found' });
        return res.json({
          success: false,
          sessionId: actualSessionId,
          question: question.trim(),
          answer,
          relevantDocuments: [],
          responseTime: Date.now() - startTime,
          contextInfo: {
            byIndex: true,
            error: 'Not found',
            index: questionAnalysis.index
          }
        });
      }
    }

    res.json({
      success: true,
      sessionId: actualSessionId,
      question: question.trim(),
      answer: result.answer,
      relevantDocuments: result.relevantDocuments || [],
      responseTime: result.responseTime || (Date.now() - startTime),
      contextInfo: {
        hasReference: referenceResolution.hasReference,
        resolved: referenceResolution.hasReference,
        resolvedQuestion: referenceResolution.hasReference ? processQuestion : undefined,
        referencedDocuments: referenceResolution.referencedDocuments || [],
        analysisResult: questionAnalysis,
        dataSources: integratedData.metadata?.sources || [],
        referenceAnalysis: referenceResolution.analysis || {}
      }
    });

  } catch (error) {
    console.error('Error processing question:', error);
    res.status(500).json({ success: false, error: error.message });
  }
};

// Get Q&A history
const getHistory = async (req, res) => {
  try {
    const limit = parseInt(req.query.limit) || 50;
    const questions = await db.getQuestions(limit);
    res.json({ success: true, questions });
  } catch (error) {
    console.error('Error fetching history:', error);
    res.status(500).json({ success: false, error: error.message });
  }
};

// Summarize document
const summarizeDocument = async (req, res) => {
  try {
    const documentId = req.params.id;
    const result = await geminiService.summarizeDocument(documentId);
    res.json({ success: true, summary: result });
  } catch (error) {
    console.error('Error summarizing document:', error);
    res.status(500).json({ success: false, error: error.message });
  }
};

// Extract key information
const extractKeyInfo = async (req, res) => {
  try {
    const { searchTerm } = req.body;
    
    if (!searchTerm || searchTerm.trim().length === 0) {
      return res.status(400).json({ success: false, error: 'Search term is required' });
    }

    const result = await geminiService.extractKeyInfo(searchTerm.trim());
    res.json({ success: true, result });

  } catch (error) {
    console.error('Error extracting key info:', error);
    res.status(500).json({ success: false, error: error.message });
  }
};

// Get conversation history
const getConversationHistory = async (req, res) => {
  try {
    const { sessionId } = req.params;
    const { limit } = req.query;

    if (!sessionId) {
      return res.status(400).json({ success: false, error: 'Session ID is required' });
    }

    const history = await conversationService.getConversationHistory(sessionId, parseInt(limit) || 10);
    const context = await conversationService.getSessionContext(sessionId);

    res.json({
      success: true,
      sessionId,
      history,
      context,
      totalMessages: history.length
    });

  } catch (error) {
    console.error('Error getting conversation history:', error);
    res.status(500).json({ success: false, error: error.message });
  }
};

// Get conversation statistics
const getConversationStats = async (req, res) => {
  try {
    const { sessionId } = req.params;

    if (!sessionId) {
      return res.status(400).json({ success: false, error: 'Session ID is required' });
    }

    const stats = await conversationService.getConversationStats(sessionId);

    if (!stats) {
      return res.status(404).json({ success: false, error: 'Conversation not found' });
    }

    res.json({
      success: true,
      stats
    });

  } catch (error) {
    console.error('Error getting conversation stats:', error);
    res.status(500).json({ success: false, error: error.message });
  }
};

// End conversation session
const endConversation = async (req, res) => {
  try {
    const { sessionId } = req.params;

    if (!sessionId) {
      return res.status(400).json({ success: false, error: 'Session ID is required' });
    }

    await conversationService.expireSession(sessionId);

    res.json({
      success: true,
      message: 'Conversation ended successfully',
      sessionId
    });

  } catch (error) {
    console.error('Error ending conversation:', error);
    res.status(500).json({ success: false, error: error.message });
  }
};

module.exports = {
  askQuestion,
  getHistory,
  summarizeDocument,
  extractKeyInfo,
  getConversationHistory,
  getConversationStats,
  endConversation
}; 
const { GoogleGenerativeAI } = require('@google/generative-ai');
const { db } = require('./database');
require('dotenv').config();

class GeminiService {
  constructor() {
    this.genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
    this.model = this.genAI.getGenerativeModel({ model: 'gemini-2.5-flash' });
  }

  // Split text into chunks for better processing
  chunkText(text, maxLength = 3000) {
    const chunks = [];
    let currentChunk = '';
    
    const sentences = text.split(/[.!?]+/);
    
    for (const sentence of sentences) {
      if (currentChunk.length + sentence.length > maxLength) {
        if (currentChunk.trim()) {
          chunks.push(currentChunk.trim());
        }
        currentChunk = sentence;
      } else {
        currentChunk += sentence + '. ';
      }
    }
    
    if (currentChunk.trim()) {
      chunks.push(currentChunk.trim());
    }
    
    return chunks;
  }

  // Find relevant documents based on question
  async findRelevantDocuments(question, limit = 5) {
    try {
      // Simple keyword search - can be improved with vector search
      const keywords = question.toLowerCase().split(/\s+/)
        .filter(word => word.length > 2)
        .slice(0, 5);
      
      const documents = await db.getDocuments();
      const relevantDocs = [];
      
      for (const doc of documents) {
        if (!doc.content_text) continue;
        
        const content = doc.content_text.toLowerCase();
        let relevanceScore = 0;
        
        for (const keyword of keywords) {
          const matches = (content.match(new RegExp(keyword, 'g')) || []).length;
          relevanceScore += matches;
        }
        
        if (relevanceScore > 0) {
          relevantDocs.push({ ...doc, relevanceScore });
        }
      }
      
      return relevantDocs
        .sort((a, b) => b.relevanceScore - a.relevanceScore)
        .slice(0, limit);
    } catch (error) {
      console.error('Error finding relevant documents:', error);
      throw error;
    }
  }

  // Generate context from relevant documents
  generateContext(documents) {
    let context = '';
    
    documents.forEach((doc, index) => {
      context += `\n[T√†i li·ªáu ${index + 1}: ${doc.original_name}]\n`;
      // Limit context length to avoid token limits
      const content = doc.content_text.substring(0, 2000);
      context += content + '\n';
    });
    
    return context;
  }

  // Content policy - check for inappropriate content
  isSensitiveContent(question) {
    const sensitivePatterns = [
      // Sexual content
      /sex|t√¨nh d·ª•c|l√†m t√¨nh|quan h·ªá|khi√™u d√¢m|porn|xxx|nude|n√≥ng b·ªèng|g·ª£i c·∫£m/i,
      // Violence/weapons
      /s√∫ng|ƒë·∫°n|v≈© kh√≠|gi·∫øt|ch·∫øt|b·∫°o l·ª±c|ƒë√°nh nhau|weapon|gun|kill|violence|bomb|n·ªï|ma t√∫y|drug/i,
      // Hate speech
      /ch·ª≠i|m·∫Øng|gh√©t|khinh|ph√¢n bi·ªát|racist|hate/i,
      // Illegal activities
      /hack|l·ª´a ƒë·∫£o|scam|cheat|gian l·∫≠n|b·∫•t h·ª£p ph√°p|illegal/i,
      // Gambling
      /c·ªù b·∫°c|gambling|bet|c∆∞·ª£c|casino/i
    ];
    
    return sensitivePatterns.some(pattern => pattern.test(question.trim()));
  }

  // Check if question is asking for specific document information
  isDocumentSpecificQuestion(question) {
    // Strong indicators of document-specific questions
    const strongDocumentKeywords = [
      'quy ƒë·ªãnh', 'ch√≠nh s√°ch', 'policy', 't√†i li·ªáu', 'vƒÉn b·∫£n', 'h∆∞·ªõng d·∫´n',
      'quy tr√¨nh', 'process', 'procedure', 'ph√≤ng ban', 'department',
      'ngh·ªâ ph√©p', 'leave', 'vacation', 'l∆∞∆°ng', 'salary', 'th∆∞·ªüng', 'bonus',
      'k·ª∑ lu·∫≠t', 'discipline', 'vi ph·∫°m', 'violation', 'ƒë√°nh gi√°', 'evaluation',
      'tuy·ªÉn d·ª•ng', 'recruitment', 'training', 'ƒë√†o t·∫°o', 'b·∫£o hi·ªÉm', 'insurance',
      'h·ª£p ƒë·ªìng', 'contract', 'th·ªèa thu·∫≠n', 'agreement', 'b√°o c√°o', 'report'
    ];
    
    // Company-related phrases that indicate document queries vs general questions
    const companyDocumentPhrases = [
      'quy ƒë·ªãnh c·ªßa c√¥ng ty', 'ch√≠nh s√°ch c√¥ng ty', 'c√¥ng ty quy ƒë·ªãnh',
      'trong c√¥ng ty', '·ªü c√¥ng ty', 't·∫°i c√¥ng ty', 'c√¥ng ty c√≥'
    ];
    
    const questionLower = question.toLowerCase();
    
    // Check for strong document keywords
    const hasStrongKeyword = strongDocumentKeywords.some(keyword => 
      questionLower.includes(keyword.toLowerCase())
    );
    
    // Check for company document phrases
    const hasCompanyDocumentPhrase = companyDocumentPhrases.some(phrase =>
      questionLower.includes(phrase.toLowerCase())
    );
    
    // Don't treat general "What is X company?" questions as document-specific
    const isGeneralCompanyQuestion = questionLower.match(/^.*(l√† c√¥ng ty n√†o|l√† c√¥ng ty g√¨|what.*company)/);
    
    return (hasStrongKeyword || hasCompanyDocumentPhrase) && !isGeneralCompanyQuestion;
  }

  // Check if question is a general greeting or system question
  isGeneralQuestion(question) {
    const greetingPatterns = [
      /^(xin ch√†o|hello|hi|ch√†o|hey)/i,
      /^(c·∫£m ∆°n|thank you|thanks)/i,
      /^(b·∫°n l√† ai|what are you|who are you)/i,
      /^(b·∫°n c√≥ th·ªÉ l√†m g√¨|what can you do)/i,
      /^(h∆∞·ªõng d·∫´n|help|gi√∫p ƒë·ª°)$/i,
      /^(h·ªá th·ªëng|system|ho·∫°t ƒë·ªông)/i,
      /^(test|testing|th·ª≠ nghi·ªám)$/i
    ];
    
    return greetingPatterns.some(pattern => pattern.test(question.trim()));
  }

  // Handle general questions without document search
  async handleGeneralQuestion(question) {
    const lowerQuestion = question.toLowerCase().trim();
    
    if (lowerQuestion.includes('xin ch√†o') || lowerQuestion.includes('ch√†o') || lowerQuestion.includes('hello') || lowerQuestion.includes('hi')) {
      return 'Xin ch√†o! T√¥i l√† tr·ª£ l√Ω AI c·ªßa h·ªá th·ªëng qu·∫£n l√Ω ki·∫øn th·ª©c PDF. T√¥i c√≥ th·ªÉ gi√∫p b·∫°n:\n\n‚Ä¢ Tr·∫£ l·ªùi c√¢u h·ªèi d·ª±a tr√™n t√†i li·ªáu ƒë√£ upload\n‚Ä¢ T√¨m ki·∫øm th√¥ng tin trong t√†i li·ªáu\n‚Ä¢ T√≥m t·∫Øt n·ªôi dung t√†i li·ªáu\n‚Ä¢ Tr√≠ch xu·∫•t th√¥ng tin quan tr·ªçng\n\nH√£y upload t√†i li·ªáu PDF v√† ƒë·∫∑t c√¢u h·ªèi, t√¥i s·∫Ω gi√∫p b·∫°n t√¨m c√¢u tr·∫£ l·ªùi!';
    }
    
    if (lowerQuestion.includes('c·∫£m ∆°n') || lowerQuestion.includes('thank you') || lowerQuestion.includes('thanks')) {
      return 'Kh√¥ng c√≥ g√¨! T√¥i lu√¥n s·∫µn s√†ng gi√∫p ƒë·ª° b·∫°n v·ªõi c√°c c√¢u h·ªèi v·ªÅ t√†i li·ªáu. H√£y ti·∫øp t·ª•c ƒë·∫∑t c√¢u h·ªèi n·∫øu c·∫ßn nh√©!';
    }
    
    if (lowerQuestion.includes('b·∫°n l√† ai') || lowerQuestion.includes('what are you') || lowerQuestion.includes('who are you')) {
      return 'T√¥i l√† tr·ª£ l√Ω AI ƒë∆∞·ª£c t√≠ch h·ª£p v·ªõi Gemini AI, chuy√™n tr·∫£ l·ªùi c√¢u h·ªèi d·ª±a tr√™n c√°c t√†i li·ªáu PDF trong h·ªá th·ªëng. T√¥i c√≥ th·ªÉ gi√∫p b·∫°n t√¨m ki·∫øm th√¥ng tin, tr·∫£ l·ªùi c√¢u h·ªèi v√† t√≥m t·∫Øt n·ªôi dung t·ª´ c√°c t√†i li·ªáu ƒë√£ ƒë∆∞·ª£c upload.';
    }
    
    if (lowerQuestion.includes('l√†m g√¨') || lowerQuestion.includes('what can you do') || lowerQuestion.includes('h∆∞·ªõng d·∫´n') || lowerQuestion.includes('help')) {
      return 'T√¥i c√≥ th·ªÉ gi√∫p b·∫°n:\n\nüìÑ **Qu·∫£n l√Ω t√†i li·ªáu**\n‚Ä¢ Upload v√† x·ª≠ l√Ω file PDF\n‚Ä¢ T√¨m ki·∫øm trong t√†i li·ªáu\n‚Ä¢ T√≥m t·∫Øt n·ªôi dung\n\nüí¨ **H·ªèi ƒë√°p th√¥ng minh**\n‚Ä¢ Tr·∫£ l·ªùi c√¢u h·ªèi d·ª±a tr√™n t√†i li·ªáu\n‚Ä¢ Tr√≠ch xu·∫•t th√¥ng tin quan tr·ªçng\n‚Ä¢ T√¨m ki·∫øm semantic\n\nüîç **T√¨m ki·∫øm**\n‚Ä¢ T√¨m theo t·ª´ kh√≥a\n‚Ä¢ T√¨m theo ch·ªß ƒë·ªÅ\n‚Ä¢ L·ªçc theo t√†i li·ªáu\n\nH√£y upload t√†i li·ªáu PDF v√† b·∫Øt ƒë·∫ßu ƒë·∫∑t c√¢u h·ªèi!';
    }
    
    if (lowerQuestion.includes('h·ªá th·ªëng') || lowerQuestion.includes('system') || lowerQuestion.includes('ho·∫°t ƒë·ªông') || lowerQuestion.includes('test')) {
      return 'H·ªá th·ªëng PDF Knowledge Management ƒëang ho·∫°t ƒë·ªông b√¨nh th∆∞·ªùng! üöÄ\n\n‚úÖ K·∫øt n·ªëi database: OK\n‚úÖ Gemini AI: OK\n‚úÖ Upload PDF: S·∫µn s√†ng\n‚úÖ Q&A: S·∫µn s√†ng\n\nB·∫°n c√≥ th·ªÉ b·∫Øt ƒë·∫ßu upload t√†i li·ªáu PDF v√† ƒë·∫∑t c√¢u h·ªèi ngay b√¢y gi·ªù!';
    }
    
    return 'Xin ch√†o! T√¥i l√† tr·ª£ l√Ω AI c·ªßa h·ªá th·ªëng qu·∫£n l√Ω ki·∫øn th·ª©c PDF. ƒê·ªÉ t√¥i c√≥ th·ªÉ tr·∫£ l·ªùi c√¢u h·ªèi m·ªôt c√°ch ch√≠nh x√°c, vui l√≤ng upload t√†i li·ªáu PDF v√† ƒë·∫∑t c√¢u h·ªèi c·ª• th·ªÉ v·ªÅ n·ªôi dung t√†i li·ªáu.';
  }

  // Main Q&A function
  async askQuestion(question) {
    const startTime = Date.now();
    
    try {
      console.log(`\nüîç Processing question: "${question}"`);
      
      // Check for sensitive content first
      const isSensitive = this.isSensitiveContent(question);
      console.log(`üõ°Ô∏è Sensitive content check: ${isSensitive}`);
      
      if (isSensitive) {
        console.log(`‚ùå Blocked sensitive content`);
        const answer = 'Xin l·ªói, t√¥i kh√¥ng th·ªÉ tr·∫£ l·ªùi c√¢u h·ªèi n√†y v√¨ n√≥ c√≥ th·ªÉ ch·ª©a n·ªôi dung kh√¥ng ph√π h·ª£p. T√¥i ch·ªâ c√≥ th·ªÉ h·ªó tr·ª£ v·ªõi c√°c c√¢u h·ªèi t√≠ch c·ª±c v√† c√≥ t√≠nh x√¢y d·ª±ng. Vui l√≤ng ƒë·∫∑t c√¢u h·ªèi kh√°c.';
        const responseTime = Date.now() - startTime;
        
        // Save to database for monitoring
        await db.createQuestion({
          question,
          answer,
          documentIds: [],
          responseTime
        });
        
        return {
          answer,
          documentIds: [],
          relevantDocuments: [],
          responseTime
        };
      }

      // Check if it's a general question first
      const isGeneral = this.isGeneralQuestion(question);
      console.log(`üí¨ General question check: ${isGeneral}`);
      
      if (isGeneral) {
        console.log(`‚úÖ Handling as general greeting`);
        const answer = await this.handleGeneralQuestion(question);
        const responseTime = Date.now() - startTime;
        
        // Save to database
        await db.createQuestion({
          question,
          answer,
          documentIds: [],
          responseTime
        });
        
        return {
          answer,
          documentIds: [],
          relevantDocuments: [],
          responseTime
        };
      }
      
      // Check if it's a document-specific question
      const isDocumentSpecific = this.isDocumentSpecificQuestion(question);
      console.log(`üìÑ Document-specific check: ${isDocumentSpecific}`);
      
      if (isDocumentSpecific) {
        console.log(`üìã Searching for relevant documents...`);
        // Find relevant documents for specific questions
        const relevantDocs = await this.findRelevantDocuments(question);
        console.log(`üìä Found ${relevantDocs.length} relevant documents`);
        
        if (relevantDocs.length === 0) {
          console.log(`‚ùå No documents found, returning standard message`);
          const answer = 'Xin l·ªói, t√¥i kh√¥ng t√¨m th·∫•y t√†i li·ªáu n√†o li√™n quan ƒë·∫øn c√¢u h·ªèi c·ªßa b·∫°n. Vui l√≤ng:\n\n‚Ä¢ Ki·ªÉm tra l·∫°i t·ª´ kh√≥a\n‚Ä¢ Upload th√™m t√†i li·ªáu li√™n quan\n‚Ä¢ Th·ª≠ ƒë·∫∑t c√¢u h·ªèi kh√°c\n\nB·∫°n c√≥ th·ªÉ s·ª≠ d·ª•ng ch·ª©c nƒÉng t√¨m ki·∫øm ƒë·ªÉ xem c√°c t√†i li·ªáu hi·ªán c√≥ trong h·ªá th·ªëng.';
          const responseTime = Date.now() - startTime;
          
          // Save to database
          await db.createQuestion({
            question,
            answer,
            documentIds: [],
            responseTime
          });
          
          return {
            answer,
            documentIds: [],
            relevantDocuments: [],
            responseTime
          };
        }
        
        // Process with documents
        return await this.processWithDocuments(question, relevantDocs, startTime);
      }
      
      // For general questions, use Gemini without documents
      console.log(`ü§ñ Handling as general chatbot question`);
      const answer = await this.handleGeneralChatbotQuestion(question);
      const responseTime = Date.now() - startTime;
      console.log(`‚úÖ Generated answer: ${answer.substring(0, 50)}...`);
      
      // Save to database
      await db.createQuestion({
        question,
        answer,
        documentIds: [],
        responseTime
      });
      
      return {
        answer,
        documentIds: [],
        relevantDocuments: [],
        responseTime
      };
      
    } catch (error) {
      console.error('Error in askQuestion:', error);
      throw new Error('C√≥ l·ªói x·∫£y ra khi x·ª≠ l√Ω c√¢u h·ªèi. Vui l√≤ng th·ª≠ l·∫°i.');
    }
  }

  // Handle general chatbot questions without documents
  async handleGeneralChatbotQuestion(question) {
    try {
      console.log(`ü§ñ Calling Gemini API for general question...`);
      
      const prompt = `B·∫°n l√† m·ªôt tr·ª£ l√Ω AI th√¢n thi·ªán v√† h·ªØu √≠ch. H√£y tr·∫£ l·ªùi c√¢u h·ªèi sau m·ªôt c√°ch t·ª± nhi√™n v√† h·ªØu √≠ch:

NGUY√äN T·∫ÆC:
1. Tr·∫£ l·ªùi b·∫±ng ti·∫øng Vi·ªát m·ªôt c√°ch t·ª± nhi√™n v√† th√¢n thi·ªán
2. N·∫øu c√¢u h·ªèi v·ªÅ ki·∫øn th·ª©c chung, h√£y tr·∫£ l·ªùi v·ªõi th√¥ng tin ch√≠nh x√°c
3. N·∫øu kh√¥ng bi·∫øt, h√£y th·∫≥ng th·∫Øn n√≥i "T√¥i kh√¥ng bi·∫øt"
4. Lu√¥n t√≠ch c·ª±c v√† h·ªØu √≠ch
5. Kh√¥ng tr·∫£ l·ªùi v·ªÅ n·ªôi dung nh·∫°y c·∫£m

C√ÇUH·ªéI: ${question}

TR√ÅL·ªúI:`;

      const result = await this.model.generateContent(prompt);
      const response = await result.response;
      const answer = response.text();
      console.log(`‚úÖ Gemini API response received`);
      return answer;
    } catch (error) {
      console.error('Error in handleGeneralChatbotQuestion:', error);
      console.error('Error details:', error.message);
      
      // Fallback response for common questions
      if (question.toLowerCase().includes('vi·ªát nam') && question.toLowerCase().includes('t·ªânh')) {
        return 'Vi·ªát Nam c√≥ 63 t·ªânh th√†nh ph·ªë, bao g·ªìm 58 t·ªânh v√† 5 th√†nh ph·ªë tr·ª±c thu·ªôc trung ∆∞∆°ng (H√† N·ªôi, TP.HCM, ƒê√† N·∫µng, H·∫£i Ph√≤ng, C·∫ßn Th∆°).';
      }
      
      if (question.toLowerCase().includes('ph√°t ƒë·∫°t')) {
        return 'T√¥i c·∫ßn th√™m th√¥ng tin ƒë·ªÉ c√≥ th·ªÉ tr·∫£ l·ªùi ch√≠nh x√°c v·ªÅ c√¥ng ty Ph√°t ƒê·∫°t. ƒê√¢y c√≥ th·ªÉ l√† t√™n c·ªßa nhi·ªÅu c√¥ng ty kh√°c nhau. B·∫°n c√≥ th·ªÉ cung c·∫•p th√™m context ho·∫∑c upload t√†i li·ªáu v·ªÅ c√¥ng ty n√†y ƒë·ªÉ t√¥i c√≥ th·ªÉ tr·∫£ l·ªùi ch√≠nh x√°c h∆°n?';
      }
      
      return 'Xin l·ªói, t√¥i ƒëang g·∫∑p v·∫•n ƒë·ªÅ k·ªπ thu·∫≠t v·ªõi API. Vui l√≤ng th·ª≠ l·∫°i sau ho·∫∑c ƒë·∫∑t c√¢u h·ªèi kh√°c.';
    }
  }

  // Process questions with documents
  async processWithDocuments(question, relevantDocs, startTime) {
    try {

      // Generate context from relevant documents
      const context = this.generateContext(relevantDocs);
      
      // Create prompt for Gemini
      const prompt = `
B·∫°n l√† m·ªôt tr·ª£ l√Ω AI chuy√™n nghi·ªáp, nhi·ªám v·ª• c·ªßa b·∫°n l√† tr·∫£ l·ªùi c√¢u h·ªèi d·ª±a tr√™n c√°c t√†i li·ªáu c√¥ng ty ƒë∆∞·ª£c cung c·∫•p.

NGUY√äN T·∫ÆC QUAN TR·ªåNG:
1. CH·ªà tr·∫£ l·ªùi d·ª±a tr√™n th√¥ng tin c√≥ trong t√†i li·ªáu ƒë∆∞·ª£c cung c·∫•p
2. N·∫øu kh√¥ng c√≥ th√¥ng tin, h√£y n√≥i "Th√¥ng tin n√†y kh√¥ng c√≥ trong t√†i li·ªáu hi·ªán t·∫°i"
3. Tr·∫£ l·ªùi b·∫±ng ti·∫øng Vi·ªát, r√µ r√†ng v√† chuy√™n nghi·ªáp
4. Tr√≠ch d·∫´n t√™n t√†i li·ªáu khi c√≥ th·ªÉ
5. N·∫øu c√≥ nhi·ªÅu th√¥ng tin li√™n quan, h√£y t·ªïng h·ª£p m·ªôt c√°ch logic

NG·ªÆ C·∫¢NH T√ÄI LI·ªÜU:
${context}

C√ÇUH·ªéI: ${question}

TR√ÅL·ªúI:`;

      // Generate response using Gemini
      const result = await this.model.generateContent(prompt);
      const response = await result.response;
      const answer = response.text();

      const responseTime = Date.now() - startTime;
      const documentIds = relevantDocs.map(doc => doc.id);

      // Save question and answer to database
      await db.createQuestion({
        question,
        answer,
        documentIds,
        responseTime
      });

      return {
        answer,
        documentIds,
        relevantDocuments: relevantDocs.map(doc => ({
          id: doc.id,
          name: doc.original_name,
          relevanceScore: doc.relevanceScore
        })),
        responseTime
      };

    } catch (error) {
      console.error('Error in processWithDocuments:', error);
      throw new Error('C√≥ l·ªói x·∫£y ra khi x·ª≠ l√Ω c√¢u h·ªèi. Vui l√≤ng th·ª≠ l·∫°i.');
    }
  }

  // Summarize document content
  async summarizeDocument(documentId) {
    try {
      const document = await db.getDocumentById(documentId);
      
      if (!document || !document.content_text) {
        throw new Error('Kh√¥ng t√¨m th·∫•y t√†i li·ªáu ho·∫∑c t√†i li·ªáu ch∆∞a ƒë∆∞·ª£c x·ª≠ l√Ω');
      }

      const prompt = `
H√£y t√≥m t·∫Øt n·ªôi dung c·ªßa t√†i li·ªáu sau m·ªôt c√°ch ng·∫Øn g·ªçn v√† s√∫c t√≠ch:

T√äN T√ÄI LI·ªÜU: ${document.original_name}

N·ªòI DUNG:
${document.content_text.substring(0, 4000)}

Y√™u c·∫ßu:
- T√≥m t·∫Øt b·∫±ng ti·∫øng Vi·ªát
- N√™u r√µ c√°c ƒëi·ªÉm ch√≠nh
- ƒê·ªô d√†i kho·∫£ng 200-300 t·ª´
- S·ª≠ d·ª•ng bullet points n·∫øu c·∫ßn

T√ìM T·∫ÆT:`;

      const result = await this.model.generateContent(prompt);
      const response = await result.response;
      
      return {
        summary: response.text(),
        documentName: document.original_name,
        documentId: document.id
      };

    } catch (error) {
      console.error('Error in summarizeDocument:', error);
      throw error;
    }
  }

  // Extract key information from documents
  async extractKeyInfo(searchTerm) {
    try {
      const documents = await db.searchDocuments(searchTerm);
      
      if (documents.length === 0) {
        return {
          info: 'Kh√¥ng t√¨m th·∫•y th√¥ng tin n√†o li√™n quan.',
          documents: []
        };
      }

      const context = this.generateContext(documents.slice(0, 3));
      
      const prompt = `
T·ª´ c√°c t√†i li·ªáu sau, h√£y tr√≠ch xu·∫•t th√¥ng tin quan tr·ªçng li√™n quan ƒë·∫øn "${searchTerm}":

${context}

Y√™u c·∫ßu:
- Tr√≠ch xu·∫•t th√¥ng tin ch√≠nh x√°c t·ª´ t√†i li·ªáu
- S·∫Øp x·∫øp theo m·ª©c ƒë·ªô quan tr·ªçng
- Ghi r√µ ngu·ªìn t√†i li·ªáu
- Tr·∫£ l·ªùi b·∫±ng ti·∫øng Vi·ªát

TH√îNG TIN TR√çCH XU·∫§T:`;

      const result = await this.model.generateContent(prompt);
      const response = await result.response;
      
      return {
        info: response.text(),
        documents: documents.map(doc => ({
          id: doc.id,
          name: doc.original_name,
          uploadDate: doc.upload_date
        }))
      };

    } catch (error) {
      console.error('Error in extractKeyInfo:', error);
      throw error;
    }
  }
}

module.exports = new GeminiService(); 